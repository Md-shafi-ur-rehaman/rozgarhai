
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model FreelancerProfile
 * 
 */
export type FreelancerProfile = $Result.DefaultSelection<Prisma.$FreelancerProfilePayload>
/**
 * Model ClientProfile
 * 
 */
export type ClientProfile = $Result.DefaultSelection<Prisma.$ClientProfilePayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model FreelancerSkill
 * 
 */
export type FreelancerSkill = $Result.DefaultSelection<Prisma.$FreelancerSkillPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectSkill
 * 
 */
export type ProjectSkill = $Result.DefaultSelection<Prisma.$ProjectSkillPayload>
/**
 * Model Bid
 * 
 */
export type Bid = $Result.DefaultSelection<Prisma.$BidPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AdminAction
 * 
 */
export type AdminAction = $Result.DefaultSelection<Prisma.$AdminActionPayload>
/**
 * Model Gig
 * 
 */
export type Gig = $Result.DefaultSelection<Prisma.$GigPayload>
/**
 * Model GigOrder
 * 
 */
export type GigOrder = $Result.DefaultSelection<Prisma.$GigOrderPayload>
/**
 * Model GigReview
 * 
 */
export type GigReview = $Result.DefaultSelection<Prisma.$GigReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  CLIENT: 'CLIENT',
  FREELANCER: 'FREELANCER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ProjectStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const BidStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type BidStatus = (typeof BidStatus)[keyof typeof BidStatus]


export const ContractStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  TERMINATED: 'TERMINATED',
  DISPUTED: 'DISPUTED'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const NotificationType: {
  BID_RECEIVED: 'BID_RECEIVED',
  BID_ACCEPTED: 'BID_ACCEPTED',
  CONTRACT_CREATED: 'CONTRACT_CREATED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  PROJECT_UPDATE: 'PROJECT_UPDATE',
  REVIEW_RECEIVED: 'REVIEW_RECEIVED',
  ADMIN_ACTION: 'ADMIN_ACTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const AdminActionType: {
  USER_SUSPEND: 'USER_SUSPEND',
  USER_ACTIVATE: 'USER_ACTIVATE',
  PROJECT_REMOVE: 'PROJECT_REMOVE',
  PROJECT_FEATURE: 'PROJECT_FEATURE',
  WARNING_ISSUED: 'WARNING_ISSUED',
  DISPUTE_RESOLVED: 'DISPUTE_RESOLVED'
};

export type AdminActionType = (typeof AdminActionType)[keyof typeof AdminActionType]


export const GigStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DELETED: 'DELETED'
};

export type GigStatus = (typeof GigStatus)[keyof typeof GigStatus]


export const GigOrderStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type GigOrderStatus = (typeof GigOrderStatus)[keyof typeof GigOrderStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type BidStatus = $Enums.BidStatus

export const BidStatus: typeof $Enums.BidStatus

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type AdminActionType = $Enums.AdminActionType

export const AdminActionType: typeof $Enums.AdminActionType

export type GigStatus = $Enums.GigStatus

export const GigStatus: typeof $Enums.GigStatus

export type GigOrderStatus = $Enums.GigOrderStatus

export const GigOrderStatus: typeof $Enums.GigOrderStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.freelancerProfile`: Exposes CRUD operations for the **FreelancerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelancerProfiles
    * const freelancerProfiles = await prisma.freelancerProfile.findMany()
    * ```
    */
  get freelancerProfile(): Prisma.FreelancerProfileDelegate<ExtArgs>;

  /**
   * `prisma.clientProfile`: Exposes CRUD operations for the **ClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientProfiles
    * const clientProfiles = await prisma.clientProfile.findMany()
    * ```
    */
  get clientProfile(): Prisma.ClientProfileDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.freelancerSkill`: Exposes CRUD operations for the **FreelancerSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelancerSkills
    * const freelancerSkills = await prisma.freelancerSkill.findMany()
    * ```
    */
  get freelancerSkill(): Prisma.FreelancerSkillDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectSkill`: Exposes CRUD operations for the **ProjectSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSkills
    * const projectSkills = await prisma.projectSkill.findMany()
    * ```
    */
  get projectSkill(): Prisma.ProjectSkillDelegate<ExtArgs>;

  /**
   * `prisma.bid`: Exposes CRUD operations for the **Bid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bids
    * const bids = await prisma.bid.findMany()
    * ```
    */
  get bid(): Prisma.BidDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.adminAction`: Exposes CRUD operations for the **AdminAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActions
    * const adminActions = await prisma.adminAction.findMany()
    * ```
    */
  get adminAction(): Prisma.AdminActionDelegate<ExtArgs>;

  /**
   * `prisma.gig`: Exposes CRUD operations for the **Gig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gigs
    * const gigs = await prisma.gig.findMany()
    * ```
    */
  get gig(): Prisma.GigDelegate<ExtArgs>;

  /**
   * `prisma.gigOrder`: Exposes CRUD operations for the **GigOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GigOrders
    * const gigOrders = await prisma.gigOrder.findMany()
    * ```
    */
  get gigOrder(): Prisma.GigOrderDelegate<ExtArgs>;

  /**
   * `prisma.gigReview`: Exposes CRUD operations for the **GigReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GigReviews
    * const gigReviews = await prisma.gigReview.findMany()
    * ```
    */
  get gigReview(): Prisma.GigReviewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    FreelancerProfile: 'FreelancerProfile',
    ClientProfile: 'ClientProfile',
    Skill: 'Skill',
    FreelancerSkill: 'FreelancerSkill',
    Project: 'Project',
    ProjectSkill: 'ProjectSkill',
    Bid: 'Bid',
    Contract: 'Contract',
    Payment: 'Payment',
    Message: 'Message',
    Review: 'Review',
    Notification: 'Notification',
    AdminAction: 'AdminAction',
    Gig: 'Gig',
    GigOrder: 'GigOrder',
    GigReview: 'GigReview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "freelancerProfile" | "clientProfile" | "skill" | "freelancerSkill" | "project" | "projectSkill" | "bid" | "contract" | "payment" | "message" | "review" | "notification" | "adminAction" | "gig" | "gigOrder" | "gigReview"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      FreelancerProfile: {
        payload: Prisma.$FreelancerProfilePayload<ExtArgs>
        fields: Prisma.FreelancerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelancerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelancerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          findFirst: {
            args: Prisma.FreelancerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelancerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          findMany: {
            args: Prisma.FreelancerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>[]
          }
          create: {
            args: Prisma.FreelancerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          createMany: {
            args: Prisma.FreelancerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelancerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>[]
          }
          delete: {
            args: Prisma.FreelancerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          update: {
            args: Prisma.FreelancerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          deleteMany: {
            args: Prisma.FreelancerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelancerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FreelancerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerProfilePayload>
          }
          aggregate: {
            args: Prisma.FreelancerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelancerProfile>
          }
          groupBy: {
            args: Prisma.FreelancerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelancerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelancerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<FreelancerProfileCountAggregateOutputType> | number
          }
        }
      }
      ClientProfile: {
        payload: Prisma.$ClientProfilePayload<ExtArgs>
        fields: Prisma.ClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findFirst: {
            args: Prisma.ClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findMany: {
            args: Prisma.ClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          create: {
            args: Prisma.ClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          createMany: {
            args: Prisma.ClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          delete: {
            args: Prisma.ClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          update: {
            args: Prisma.ClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          aggregate: {
            args: Prisma.ClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientProfile>
          }
          groupBy: {
            args: Prisma.ClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      FreelancerSkill: {
        payload: Prisma.$FreelancerSkillPayload<ExtArgs>
        fields: Prisma.FreelancerSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelancerSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelancerSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          findFirst: {
            args: Prisma.FreelancerSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelancerSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          findMany: {
            args: Prisma.FreelancerSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>[]
          }
          create: {
            args: Prisma.FreelancerSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          createMany: {
            args: Prisma.FreelancerSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelancerSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>[]
          }
          delete: {
            args: Prisma.FreelancerSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          update: {
            args: Prisma.FreelancerSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          deleteMany: {
            args: Prisma.FreelancerSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelancerSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FreelancerSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerSkillPayload>
          }
          aggregate: {
            args: Prisma.FreelancerSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelancerSkill>
          }
          groupBy: {
            args: Prisma.FreelancerSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelancerSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelancerSkillCountArgs<ExtArgs>
            result: $Utils.Optional<FreelancerSkillCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectSkill: {
        payload: Prisma.$ProjectSkillPayload<ExtArgs>
        fields: Prisma.ProjectSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          findFirst: {
            args: Prisma.ProjectSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          findMany: {
            args: Prisma.ProjectSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
          }
          create: {
            args: Prisma.ProjectSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          createMany: {
            args: Prisma.ProjectSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
          }
          delete: {
            args: Prisma.ProjectSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          update: {
            args: Prisma.ProjectSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
          }
          aggregate: {
            args: Prisma.ProjectSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSkill>
          }
          groupBy: {
            args: Prisma.ProjectSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSkillCountAggregateOutputType> | number
          }
        }
      }
      Bid: {
        payload: Prisma.$BidPayload<ExtArgs>
        fields: Prisma.BidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findFirst: {
            args: Prisma.BidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findMany: {
            args: Prisma.BidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          create: {
            args: Prisma.BidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          createMany: {
            args: Prisma.BidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          delete: {
            args: Prisma.BidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          update: {
            args: Prisma.BidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          deleteMany: {
            args: Prisma.BidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          aggregate: {
            args: Prisma.BidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBid>
          }
          groupBy: {
            args: Prisma.BidGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidCountArgs<ExtArgs>
            result: $Utils.Optional<BidCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AdminAction: {
        payload: Prisma.$AdminActionPayload<ExtArgs>
        fields: Prisma.AdminActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          findFirst: {
            args: Prisma.AdminActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          findMany: {
            args: Prisma.AdminActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>[]
          }
          create: {
            args: Prisma.AdminActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          createMany: {
            args: Prisma.AdminActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>[]
          }
          delete: {
            args: Prisma.AdminActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          update: {
            args: Prisma.AdminActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          deleteMany: {
            args: Prisma.AdminActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          aggregate: {
            args: Prisma.AdminActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAction>
          }
          groupBy: {
            args: Prisma.AdminActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActionCountAggregateOutputType> | number
          }
        }
      }
      Gig: {
        payload: Prisma.$GigPayload<ExtArgs>
        fields: Prisma.GigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          findFirst: {
            args: Prisma.GigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          findMany: {
            args: Prisma.GigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>[]
          }
          create: {
            args: Prisma.GigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          createMany: {
            args: Prisma.GigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>[]
          }
          delete: {
            args: Prisma.GigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          update: {
            args: Prisma.GigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          deleteMany: {
            args: Prisma.GigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigPayload>
          }
          aggregate: {
            args: Prisma.GigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGig>
          }
          groupBy: {
            args: Prisma.GigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GigCountArgs<ExtArgs>
            result: $Utils.Optional<GigCountAggregateOutputType> | number
          }
        }
      }
      GigOrder: {
        payload: Prisma.$GigOrderPayload<ExtArgs>
        fields: Prisma.GigOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GigOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GigOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          findFirst: {
            args: Prisma.GigOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GigOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          findMany: {
            args: Prisma.GigOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>[]
          }
          create: {
            args: Prisma.GigOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          createMany: {
            args: Prisma.GigOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GigOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>[]
          }
          delete: {
            args: Prisma.GigOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          update: {
            args: Prisma.GigOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          deleteMany: {
            args: Prisma.GigOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GigOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GigOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigOrderPayload>
          }
          aggregate: {
            args: Prisma.GigOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGigOrder>
          }
          groupBy: {
            args: Prisma.GigOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<GigOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.GigOrderCountArgs<ExtArgs>
            result: $Utils.Optional<GigOrderCountAggregateOutputType> | number
          }
        }
      }
      GigReview: {
        payload: Prisma.$GigReviewPayload<ExtArgs>
        fields: Prisma.GigReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GigReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GigReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          findFirst: {
            args: Prisma.GigReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GigReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          findMany: {
            args: Prisma.GigReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>[]
          }
          create: {
            args: Prisma.GigReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          createMany: {
            args: Prisma.GigReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GigReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>[]
          }
          delete: {
            args: Prisma.GigReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          update: {
            args: Prisma.GigReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          deleteMany: {
            args: Prisma.GigReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GigReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GigReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GigReviewPayload>
          }
          aggregate: {
            args: Prisma.GigReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGigReview>
          }
          groupBy: {
            args: Prisma.GigReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<GigReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.GigReviewCountArgs<ExtArgs>
            result: $Utils.Optional<GigReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    postedProjects: number
    bids: number
    clientContracts: number
    freelancerContracts: number
    sentMessages: number
    receivedMessages: number
    givenReviews: number
    receivedReviews: number
    notifications: number
    adminActions: number
    performedActions: number
    gigs: number
    gigOrders: number
    gigReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postedProjects?: boolean | UserCountOutputTypeCountPostedProjectsArgs
    bids?: boolean | UserCountOutputTypeCountBidsArgs
    clientContracts?: boolean | UserCountOutputTypeCountClientContractsArgs
    freelancerContracts?: boolean | UserCountOutputTypeCountFreelancerContractsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    givenReviews?: boolean | UserCountOutputTypeCountGivenReviewsArgs
    receivedReviews?: boolean | UserCountOutputTypeCountReceivedReviewsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    adminActions?: boolean | UserCountOutputTypeCountAdminActionsArgs
    performedActions?: boolean | UserCountOutputTypeCountPerformedActionsArgs
    gigs?: boolean | UserCountOutputTypeCountGigsArgs
    gigOrders?: boolean | UserCountOutputTypeCountGigOrdersArgs
    gigReviews?: boolean | UserCountOutputTypeCountGigReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFreelancerContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGivenReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGigOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGigReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigReviewWhereInput
  }


  /**
   * Count Type FreelancerProfileCountOutputType
   */

  export type FreelancerProfileCountOutputType = {
    skills: number
  }

  export type FreelancerProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | FreelancerProfileCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * FreelancerProfileCountOutputType without action
   */
  export type FreelancerProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfileCountOutputType
     */
    select?: FreelancerProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FreelancerProfileCountOutputType without action
   */
  export type FreelancerProfileCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerSkillWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    freelancers: number
    projects: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancers?: boolean | SkillCountOutputTypeCountFreelancersArgs
    projects?: boolean | SkillCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountFreelancersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerSkillWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    skills: number
    bids: number
    messages: number
    adminActions: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | ProjectCountOutputTypeCountSkillsArgs
    bids?: boolean | ProjectCountOutputTypeCountBidsArgs
    messages?: boolean | ProjectCountOutputTypeCountMessagesArgs
    adminActions?: boolean | ProjectCountOutputTypeCountAdminActionsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAdminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    payments: number
    reviews: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | ContractCountOutputTypeCountPaymentsArgs
    reviews?: boolean | ContractCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type GigCountOutputType
   */

  export type GigCountOutputType = {
    reviews: number
    orders: number
  }

  export type GigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | GigCountOutputTypeCountReviewsArgs
    orders?: boolean | GigCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * GigCountOutputType without action
   */
  export type GigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigCountOutputType
     */
    select?: GigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GigCountOutputType without action
   */
  export type GigCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigReviewWhereInput
  }

  /**
   * GigCountOutputType without action
   */
  export type GigCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigOrderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancerProfile?: boolean | User$freelancerProfileArgs<ExtArgs>
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    postedProjects?: boolean | User$postedProjectsArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    clientContracts?: boolean | User$clientContractsArgs<ExtArgs>
    freelancerContracts?: boolean | User$freelancerContractsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    givenReviews?: boolean | User$givenReviewsArgs<ExtArgs>
    receivedReviews?: boolean | User$receivedReviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    performedActions?: boolean | User$performedActionsArgs<ExtArgs>
    gigs?: boolean | User$gigsArgs<ExtArgs>
    gigOrders?: boolean | User$gigOrdersArgs<ExtArgs>
    gigReviews?: boolean | User$gigReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancerProfile?: boolean | User$freelancerProfileArgs<ExtArgs>
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
    postedProjects?: boolean | User$postedProjectsArgs<ExtArgs>
    bids?: boolean | User$bidsArgs<ExtArgs>
    clientContracts?: boolean | User$clientContractsArgs<ExtArgs>
    freelancerContracts?: boolean | User$freelancerContractsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    givenReviews?: boolean | User$givenReviewsArgs<ExtArgs>
    receivedReviews?: boolean | User$receivedReviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    performedActions?: boolean | User$performedActionsArgs<ExtArgs>
    gigs?: boolean | User$gigsArgs<ExtArgs>
    gigOrders?: boolean | User$gigOrdersArgs<ExtArgs>
    gigReviews?: boolean | User$gigReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      freelancerProfile: Prisma.$FreelancerProfilePayload<ExtArgs> | null
      clientProfile: Prisma.$ClientProfilePayload<ExtArgs> | null
      postedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      bids: Prisma.$BidPayload<ExtArgs>[]
      clientContracts: Prisma.$ContractPayload<ExtArgs>[]
      freelancerContracts: Prisma.$ContractPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      givenReviews: Prisma.$ReviewPayload<ExtArgs>[]
      receivedReviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      adminActions: Prisma.$AdminActionPayload<ExtArgs>[]
      performedActions: Prisma.$AdminActionPayload<ExtArgs>[]
      gigs: Prisma.$GigPayload<ExtArgs>[]
      gigOrders: Prisma.$GigOrderPayload<ExtArgs>[]
      gigReviews: Prisma.$GigReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.Role
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    freelancerProfile<T extends User$freelancerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$freelancerProfileArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    postedProjects<T extends User$postedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$postedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    bids<T extends User$bidsArgs<ExtArgs> = {}>(args?: Subset<T, User$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany"> | Null>
    clientContracts<T extends User$clientContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    freelancerContracts<T extends User$freelancerContractsArgs<ExtArgs> = {}>(args?: Subset<T, User$freelancerContractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    givenReviews<T extends User$givenReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$givenReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    receivedReviews<T extends User$receivedReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    adminActions<T extends User$adminActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany"> | Null>
    performedActions<T extends User$performedActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$performedActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany"> | Null>
    gigs<T extends User$gigsArgs<ExtArgs> = {}>(args?: Subset<T, User$gigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findMany"> | Null>
    gigOrders<T extends User$gigOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$gigOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findMany"> | Null>
    gigReviews<T extends User$gigReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$gigReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.freelancerProfile
   */
  export type User$freelancerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    where?: FreelancerProfileWhereInput
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
  }

  /**
   * User.postedProjects
   */
  export type User$postedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.bids
   */
  export type User$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * User.clientContracts
   */
  export type User$clientContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * User.freelancerContracts
   */
  export type User$freelancerContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.givenReviews
   */
  export type User$givenReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.receivedReviews
   */
  export type User$receivedReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.adminActions
   */
  export type User$adminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    cursor?: AdminActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * User.performedActions
   */
  export type User$performedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    cursor?: AdminActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * User.gigs
   */
  export type User$gigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    where?: GigWhereInput
    orderBy?: GigOrderByWithRelationInput | GigOrderByWithRelationInput[]
    cursor?: GigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GigScalarFieldEnum | GigScalarFieldEnum[]
  }

  /**
   * User.gigOrders
   */
  export type User$gigOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    where?: GigOrderWhereInput
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    cursor?: GigOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GigOrderScalarFieldEnum | GigOrderScalarFieldEnum[]
  }

  /**
   * User.gigReviews
   */
  export type User$gigReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    where?: GigReviewWhereInput
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    cursor?: GigReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GigReviewScalarFieldEnum | GigReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model FreelancerProfile
   */

  export type AggregateFreelancerProfile = {
    _count: FreelancerProfileCountAggregateOutputType | null
    _avg: FreelancerProfileAvgAggregateOutputType | null
    _sum: FreelancerProfileSumAggregateOutputType | null
    _min: FreelancerProfileMinAggregateOutputType | null
    _max: FreelancerProfileMaxAggregateOutputType | null
  }

  export type FreelancerProfileAvgAggregateOutputType = {
    experience: number | null
  }

  export type FreelancerProfileSumAggregateOutputType = {
    experience: number | null
  }

  export type FreelancerProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    experience: number | null
    education: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelancerProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    experience: number | null
    education: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelancerProfileCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    experience: number
    education: number
    location: number
    languages: number
    portfolio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelancerProfileAvgAggregateInputType = {
    experience?: true
  }

  export type FreelancerProfileSumAggregateInputType = {
    experience?: true
  }

  export type FreelancerProfileMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    experience?: true
    education?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelancerProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    experience?: true
    education?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelancerProfileCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    experience?: true
    education?: true
    location?: true
    languages?: true
    portfolio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelancerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerProfile to aggregate.
     */
    where?: FreelancerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerProfiles to fetch.
     */
    orderBy?: FreelancerProfileOrderByWithRelationInput | FreelancerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelancerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelancerProfiles
    **/
    _count?: true | FreelancerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelancerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelancerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelancerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelancerProfileMaxAggregateInputType
  }

  export type GetFreelancerProfileAggregateType<T extends FreelancerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelancerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelancerProfile[P]>
      : GetScalarType<T[P], AggregateFreelancerProfile[P]>
  }




  export type FreelancerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerProfileWhereInput
    orderBy?: FreelancerProfileOrderByWithAggregationInput | FreelancerProfileOrderByWithAggregationInput[]
    by: FreelancerProfileScalarFieldEnum[] | FreelancerProfileScalarFieldEnum
    having?: FreelancerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelancerProfileCountAggregateInputType | true
    _avg?: FreelancerProfileAvgAggregateInputType
    _sum?: FreelancerProfileSumAggregateInputType
    _min?: FreelancerProfileMinAggregateInputType
    _max?: FreelancerProfileMaxAggregateInputType
  }

  export type FreelancerProfileGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string
    experience: number
    education: string | null
    location: string
    languages: string[]
    portfolio: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FreelancerProfileCountAggregateOutputType | null
    _avg: FreelancerProfileAvgAggregateOutputType | null
    _sum: FreelancerProfileSumAggregateOutputType | null
    _min: FreelancerProfileMinAggregateOutputType | null
    _max: FreelancerProfileMaxAggregateOutputType | null
  }

  type GetFreelancerProfileGroupByPayload<T extends FreelancerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelancerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelancerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelancerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], FreelancerProfileGroupByOutputType[P]>
        }
      >
    >


  export type FreelancerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    experience?: boolean
    education?: boolean
    location?: boolean
    languages?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | FreelancerProfile$skillsArgs<ExtArgs>
    _count?: boolean | FreelancerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerProfile"]>

  export type FreelancerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    experience?: boolean
    education?: boolean
    location?: boolean
    languages?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerProfile"]>

  export type FreelancerProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    experience?: boolean
    education?: boolean
    location?: boolean
    languages?: boolean
    portfolio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelancerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | FreelancerProfile$skillsArgs<ExtArgs>
    _count?: boolean | FreelancerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FreelancerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FreelancerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelancerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      skills: Prisma.$FreelancerSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string
      experience: number
      education: string | null
      location: string
      languages: string[]
      portfolio: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelancerProfile"]>
    composites: {}
  }

  type FreelancerProfileGetPayload<S extends boolean | null | undefined | FreelancerProfileDefaultArgs> = $Result.GetResult<Prisma.$FreelancerProfilePayload, S>

  type FreelancerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FreelancerProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FreelancerProfileCountAggregateInputType | true
    }

  export interface FreelancerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelancerProfile'], meta: { name: 'FreelancerProfile' } }
    /**
     * Find zero or one FreelancerProfile that matches the filter.
     * @param {FreelancerProfileFindUniqueArgs} args - Arguments to find a FreelancerProfile
     * @example
     * // Get one FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelancerProfileFindUniqueArgs>(args: SelectSubset<T, FreelancerProfileFindUniqueArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FreelancerProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FreelancerProfileFindUniqueOrThrowArgs} args - Arguments to find a FreelancerProfile
     * @example
     * // Get one FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelancerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelancerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FreelancerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileFindFirstArgs} args - Arguments to find a FreelancerProfile
     * @example
     * // Get one FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelancerProfileFindFirstArgs>(args?: SelectSubset<T, FreelancerProfileFindFirstArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FreelancerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileFindFirstOrThrowArgs} args - Arguments to find a FreelancerProfile
     * @example
     * // Get one FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelancerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelancerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FreelancerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelancerProfiles
     * const freelancerProfiles = await prisma.freelancerProfile.findMany()
     * 
     * // Get first 10 FreelancerProfiles
     * const freelancerProfiles = await prisma.freelancerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelancerProfileWithIdOnly = await prisma.freelancerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelancerProfileFindManyArgs>(args?: SelectSubset<T, FreelancerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FreelancerProfile.
     * @param {FreelancerProfileCreateArgs} args - Arguments to create a FreelancerProfile.
     * @example
     * // Create one FreelancerProfile
     * const FreelancerProfile = await prisma.freelancerProfile.create({
     *   data: {
     *     // ... data to create a FreelancerProfile
     *   }
     * })
     * 
     */
    create<T extends FreelancerProfileCreateArgs>(args: SelectSubset<T, FreelancerProfileCreateArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FreelancerProfiles.
     * @param {FreelancerProfileCreateManyArgs} args - Arguments to create many FreelancerProfiles.
     * @example
     * // Create many FreelancerProfiles
     * const freelancerProfile = await prisma.freelancerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelancerProfileCreateManyArgs>(args?: SelectSubset<T, FreelancerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelancerProfiles and returns the data saved in the database.
     * @param {FreelancerProfileCreateManyAndReturnArgs} args - Arguments to create many FreelancerProfiles.
     * @example
     * // Create many FreelancerProfiles
     * const freelancerProfile = await prisma.freelancerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelancerProfiles and only return the `id`
     * const freelancerProfileWithIdOnly = await prisma.freelancerProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelancerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelancerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FreelancerProfile.
     * @param {FreelancerProfileDeleteArgs} args - Arguments to delete one FreelancerProfile.
     * @example
     * // Delete one FreelancerProfile
     * const FreelancerProfile = await prisma.freelancerProfile.delete({
     *   where: {
     *     // ... filter to delete one FreelancerProfile
     *   }
     * })
     * 
     */
    delete<T extends FreelancerProfileDeleteArgs>(args: SelectSubset<T, FreelancerProfileDeleteArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FreelancerProfile.
     * @param {FreelancerProfileUpdateArgs} args - Arguments to update one FreelancerProfile.
     * @example
     * // Update one FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelancerProfileUpdateArgs>(args: SelectSubset<T, FreelancerProfileUpdateArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FreelancerProfiles.
     * @param {FreelancerProfileDeleteManyArgs} args - Arguments to filter FreelancerProfiles to delete.
     * @example
     * // Delete a few FreelancerProfiles
     * const { count } = await prisma.freelancerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelancerProfileDeleteManyArgs>(args?: SelectSubset<T, FreelancerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelancerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelancerProfiles
     * const freelancerProfile = await prisma.freelancerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelancerProfileUpdateManyArgs>(args: SelectSubset<T, FreelancerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FreelancerProfile.
     * @param {FreelancerProfileUpsertArgs} args - Arguments to update or create a FreelancerProfile.
     * @example
     * // Update or create a FreelancerProfile
     * const freelancerProfile = await prisma.freelancerProfile.upsert({
     *   create: {
     *     // ... data to create a FreelancerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelancerProfile we want to update
     *   }
     * })
     */
    upsert<T extends FreelancerProfileUpsertArgs>(args: SelectSubset<T, FreelancerProfileUpsertArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FreelancerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileCountArgs} args - Arguments to filter FreelancerProfiles to count.
     * @example
     * // Count the number of FreelancerProfiles
     * const count = await prisma.freelancerProfile.count({
     *   where: {
     *     // ... the filter for the FreelancerProfiles we want to count
     *   }
     * })
    **/
    count<T extends FreelancerProfileCountArgs>(
      args?: Subset<T, FreelancerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelancerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelancerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelancerProfileAggregateArgs>(args: Subset<T, FreelancerProfileAggregateArgs>): Prisma.PrismaPromise<GetFreelancerProfileAggregateType<T>>

    /**
     * Group by FreelancerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelancerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelancerProfileGroupByArgs['orderBy'] }
        : { orderBy?: FreelancerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelancerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelancerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelancerProfile model
   */
  readonly fields: FreelancerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelancerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelancerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skills<T extends FreelancerProfile$skillsArgs<ExtArgs> = {}>(args?: Subset<T, FreelancerProfile$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelancerProfile model
   */ 
  interface FreelancerProfileFieldRefs {
    readonly id: FieldRef<"FreelancerProfile", 'String'>
    readonly userId: FieldRef<"FreelancerProfile", 'String'>
    readonly title: FieldRef<"FreelancerProfile", 'String'>
    readonly description: FieldRef<"FreelancerProfile", 'String'>
    readonly experience: FieldRef<"FreelancerProfile", 'Int'>
    readonly education: FieldRef<"FreelancerProfile", 'String'>
    readonly location: FieldRef<"FreelancerProfile", 'String'>
    readonly languages: FieldRef<"FreelancerProfile", 'String[]'>
    readonly portfolio: FieldRef<"FreelancerProfile", 'Json'>
    readonly createdAt: FieldRef<"FreelancerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelancerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelancerProfile findUnique
   */
  export type FreelancerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerProfile to fetch.
     */
    where: FreelancerProfileWhereUniqueInput
  }

  /**
   * FreelancerProfile findUniqueOrThrow
   */
  export type FreelancerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerProfile to fetch.
     */
    where: FreelancerProfileWhereUniqueInput
  }

  /**
   * FreelancerProfile findFirst
   */
  export type FreelancerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerProfile to fetch.
     */
    where?: FreelancerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerProfiles to fetch.
     */
    orderBy?: FreelancerProfileOrderByWithRelationInput | FreelancerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerProfiles.
     */
    cursor?: FreelancerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerProfiles.
     */
    distinct?: FreelancerProfileScalarFieldEnum | FreelancerProfileScalarFieldEnum[]
  }

  /**
   * FreelancerProfile findFirstOrThrow
   */
  export type FreelancerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerProfile to fetch.
     */
    where?: FreelancerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerProfiles to fetch.
     */
    orderBy?: FreelancerProfileOrderByWithRelationInput | FreelancerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerProfiles.
     */
    cursor?: FreelancerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerProfiles.
     */
    distinct?: FreelancerProfileScalarFieldEnum | FreelancerProfileScalarFieldEnum[]
  }

  /**
   * FreelancerProfile findMany
   */
  export type FreelancerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerProfiles to fetch.
     */
    where?: FreelancerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerProfiles to fetch.
     */
    orderBy?: FreelancerProfileOrderByWithRelationInput | FreelancerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelancerProfiles.
     */
    cursor?: FreelancerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerProfiles.
     */
    skip?: number
    distinct?: FreelancerProfileScalarFieldEnum | FreelancerProfileScalarFieldEnum[]
  }

  /**
   * FreelancerProfile create
   */
  export type FreelancerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelancerProfile.
     */
    data: XOR<FreelancerProfileCreateInput, FreelancerProfileUncheckedCreateInput>
  }

  /**
   * FreelancerProfile createMany
   */
  export type FreelancerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelancerProfiles.
     */
    data: FreelancerProfileCreateManyInput | FreelancerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelancerProfile createManyAndReturn
   */
  export type FreelancerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FreelancerProfiles.
     */
    data: FreelancerProfileCreateManyInput | FreelancerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelancerProfile update
   */
  export type FreelancerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelancerProfile.
     */
    data: XOR<FreelancerProfileUpdateInput, FreelancerProfileUncheckedUpdateInput>
    /**
     * Choose, which FreelancerProfile to update.
     */
    where: FreelancerProfileWhereUniqueInput
  }

  /**
   * FreelancerProfile updateMany
   */
  export type FreelancerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelancerProfiles.
     */
    data: XOR<FreelancerProfileUpdateManyMutationInput, FreelancerProfileUncheckedUpdateManyInput>
    /**
     * Filter which FreelancerProfiles to update
     */
    where?: FreelancerProfileWhereInput
  }

  /**
   * FreelancerProfile upsert
   */
  export type FreelancerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelancerProfile to update in case it exists.
     */
    where: FreelancerProfileWhereUniqueInput
    /**
     * In case the FreelancerProfile found by the `where` argument doesn't exist, create a new FreelancerProfile with this data.
     */
    create: XOR<FreelancerProfileCreateInput, FreelancerProfileUncheckedCreateInput>
    /**
     * In case the FreelancerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelancerProfileUpdateInput, FreelancerProfileUncheckedUpdateInput>
  }

  /**
   * FreelancerProfile delete
   */
  export type FreelancerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
    /**
     * Filter which FreelancerProfile to delete.
     */
    where: FreelancerProfileWhereUniqueInput
  }

  /**
   * FreelancerProfile deleteMany
   */
  export type FreelancerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerProfiles to delete
     */
    where?: FreelancerProfileWhereInput
  }

  /**
   * FreelancerProfile.skills
   */
  export type FreelancerProfile$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    where?: FreelancerSkillWhereInput
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    cursor?: FreelancerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelancerSkillScalarFieldEnum | FreelancerSkillScalarFieldEnum[]
  }

  /**
   * FreelancerProfile without action
   */
  export type FreelancerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerProfile
     */
    select?: FreelancerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerProfileInclude<ExtArgs> | null
  }


  /**
   * Model ClientProfile
   */

  export type AggregateClientProfile = {
    _count: ClientProfileCountAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  export type ClientProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    description: string | null
    industry: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    description: string | null
    industry: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    website: number
    description: number
    industry: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientProfileMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    industry?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    industry?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    industry?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfile to aggregate.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientProfiles
    **/
    _count?: true | ClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientProfileMaxAggregateInputType
  }

  export type GetClientProfileAggregateType<T extends ClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientProfile[P]>
      : GetScalarType<T[P], AggregateClientProfile[P]>
  }




  export type ClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithAggregationInput | ClientProfileOrderByWithAggregationInput[]
    by: ClientProfileScalarFieldEnum[] | ClientProfileScalarFieldEnum
    having?: ClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientProfileCountAggregateInputType | true
    _min?: ClientProfileMinAggregateInputType
    _max?: ClientProfileMaxAggregateInputType
  }

  export type ClientProfileGroupByOutputType = {
    id: string
    userId: string
    companyName: string | null
    website: string | null
    description: string | null
    industry: string | null
    location: string
    createdAt: Date
    updatedAt: Date
    _count: ClientProfileCountAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  type GetClientProfileGroupByPayload<T extends ClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string | null
      website: string | null
      description: string | null
      industry: string | null
      location: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientProfile"]>
    composites: {}
  }

  type ClientProfileGetPayload<S extends boolean | null | undefined | ClientProfileDefaultArgs> = $Result.GetResult<Prisma.$ClientProfilePayload, S>

  type ClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientProfileCountAggregateInputType | true
    }

  export interface ClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientProfile'], meta: { name: 'ClientProfile' } }
    /**
     * Find zero or one ClientProfile that matches the filter.
     * @param {ClientProfileFindUniqueArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientProfileFindUniqueArgs>(args: SelectSubset<T, ClientProfileFindUniqueArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientProfileFindUniqueOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientProfileFindFirstArgs>(args?: SelectSubset<T, ClientProfileFindFirstArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany()
     * 
     * // Get first 10 ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientProfileFindManyArgs>(args?: SelectSubset<T, ClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientProfile.
     * @param {ClientProfileCreateArgs} args - Arguments to create a ClientProfile.
     * @example
     * // Create one ClientProfile
     * const ClientProfile = await prisma.clientProfile.create({
     *   data: {
     *     // ... data to create a ClientProfile
     *   }
     * })
     * 
     */
    create<T extends ClientProfileCreateArgs>(args: SelectSubset<T, ClientProfileCreateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientProfiles.
     * @param {ClientProfileCreateManyArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientProfileCreateManyArgs>(args?: SelectSubset<T, ClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientProfiles and returns the data saved in the database.
     * @param {ClientProfileCreateManyAndReturnArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientProfile.
     * @param {ClientProfileDeleteArgs} args - Arguments to delete one ClientProfile.
     * @example
     * // Delete one ClientProfile
     * const ClientProfile = await prisma.clientProfile.delete({
     *   where: {
     *     // ... filter to delete one ClientProfile
     *   }
     * })
     * 
     */
    delete<T extends ClientProfileDeleteArgs>(args: SelectSubset<T, ClientProfileDeleteArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientProfile.
     * @param {ClientProfileUpdateArgs} args - Arguments to update one ClientProfile.
     * @example
     * // Update one ClientProfile
     * const clientProfile = await prisma.clientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientProfileUpdateArgs>(args: SelectSubset<T, ClientProfileUpdateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientProfiles.
     * @param {ClientProfileDeleteManyArgs} args - Arguments to filter ClientProfiles to delete.
     * @example
     * // Delete a few ClientProfiles
     * const { count } = await prisma.clientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientProfileDeleteManyArgs>(args?: SelectSubset<T, ClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientProfileUpdateManyArgs>(args: SelectSubset<T, ClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientProfile.
     * @param {ClientProfileUpsertArgs} args - Arguments to update or create a ClientProfile.
     * @example
     * // Update or create a ClientProfile
     * const clientProfile = await prisma.clientProfile.upsert({
     *   create: {
     *     // ... data to create a ClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClientProfileUpsertArgs>(args: SelectSubset<T, ClientProfileUpsertArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileCountArgs} args - Arguments to filter ClientProfiles to count.
     * @example
     * // Count the number of ClientProfiles
     * const count = await prisma.clientProfile.count({
     *   where: {
     *     // ... the filter for the ClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClientProfileCountArgs>(
      args?: Subset<T, ClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientProfileAggregateArgs>(args: Subset<T, ClientProfileAggregateArgs>): Prisma.PrismaPromise<GetClientProfileAggregateType<T>>

    /**
     * Group by ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientProfile model
   */
  readonly fields: ClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientProfile model
   */ 
  interface ClientProfileFieldRefs {
    readonly id: FieldRef<"ClientProfile", 'String'>
    readonly userId: FieldRef<"ClientProfile", 'String'>
    readonly companyName: FieldRef<"ClientProfile", 'String'>
    readonly website: FieldRef<"ClientProfile", 'String'>
    readonly description: FieldRef<"ClientProfile", 'String'>
    readonly industry: FieldRef<"ClientProfile", 'String'>
    readonly location: FieldRef<"ClientProfile", 'String'>
    readonly createdAt: FieldRef<"ClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientProfile findUnique
   */
  export type ClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findUniqueOrThrow
   */
  export type ClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findFirst
   */
  export type ClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findFirstOrThrow
   */
  export type ClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findMany
   */
  export type ClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfiles to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile create
   */
  export type ClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientProfile.
     */
    data: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
  }

  /**
   * ClientProfile createMany
   */
  export type ClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile createManyAndReturn
   */
  export type ClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientProfile update
   */
  export type ClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientProfile.
     */
    data: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
    /**
     * Choose, which ClientProfile to update.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile updateMany
   */
  export type ClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile upsert
   */
  export type ClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientProfile to update in case it exists.
     */
    where: ClientProfileWhereUniqueInput
    /**
     * In case the ClientProfile found by the `where` argument doesn't exist, create a new ClientProfile with this data.
     */
    create: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
    /**
     * In case the ClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
  }

  /**
   * ClientProfile delete
   */
  export type ClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter which ClientProfile to delete.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile deleteMany
   */
  export type ClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfiles to delete
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile without action
   */
  export type ClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    category: string
    createdAt: Date
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancers?: boolean | Skill$freelancersArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancers?: boolean | Skill$freelancersArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      freelancers: Prisma.$FreelancerSkillPayload<ExtArgs>[]
      projects: Prisma.$ProjectSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    freelancers<T extends Skill$freelancersArgs<ExtArgs> = {}>(args?: Subset<T, Skill$freelancersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Skill$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }

  /**
   * Skill.freelancers
   */
  export type Skill$freelancersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    where?: FreelancerSkillWhereInput
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    cursor?: FreelancerSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelancerSkillScalarFieldEnum | FreelancerSkillScalarFieldEnum[]
  }

  /**
   * Skill.projects
   */
  export type Skill$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    cursor?: ProjectSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model FreelancerSkill
   */

  export type AggregateFreelancerSkill = {
    _count: FreelancerSkillCountAggregateOutputType | null
    _avg: FreelancerSkillAvgAggregateOutputType | null
    _sum: FreelancerSkillSumAggregateOutputType | null
    _min: FreelancerSkillMinAggregateOutputType | null
    _max: FreelancerSkillMaxAggregateOutputType | null
  }

  export type FreelancerSkillAvgAggregateOutputType = {
    yearsExperience: number | null
  }

  export type FreelancerSkillSumAggregateOutputType = {
    yearsExperience: number | null
  }

  export type FreelancerSkillMinAggregateOutputType = {
    id: string | null
    freelancerId: string | null
    skillId: string | null
    yearsExperience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelancerSkillMaxAggregateOutputType = {
    id: string | null
    freelancerId: string | null
    skillId: string | null
    yearsExperience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelancerSkillCountAggregateOutputType = {
    id: number
    freelancerId: number
    skillId: number
    yearsExperience: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelancerSkillAvgAggregateInputType = {
    yearsExperience?: true
  }

  export type FreelancerSkillSumAggregateInputType = {
    yearsExperience?: true
  }

  export type FreelancerSkillMinAggregateInputType = {
    id?: true
    freelancerId?: true
    skillId?: true
    yearsExperience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelancerSkillMaxAggregateInputType = {
    id?: true
    freelancerId?: true
    skillId?: true
    yearsExperience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelancerSkillCountAggregateInputType = {
    id?: true
    freelancerId?: true
    skillId?: true
    yearsExperience?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelancerSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerSkill to aggregate.
     */
    where?: FreelancerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerSkills to fetch.
     */
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelancerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelancerSkills
    **/
    _count?: true | FreelancerSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelancerSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelancerSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelancerSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelancerSkillMaxAggregateInputType
  }

  export type GetFreelancerSkillAggregateType<T extends FreelancerSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelancerSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelancerSkill[P]>
      : GetScalarType<T[P], AggregateFreelancerSkill[P]>
  }




  export type FreelancerSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerSkillWhereInput
    orderBy?: FreelancerSkillOrderByWithAggregationInput | FreelancerSkillOrderByWithAggregationInput[]
    by: FreelancerSkillScalarFieldEnum[] | FreelancerSkillScalarFieldEnum
    having?: FreelancerSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelancerSkillCountAggregateInputType | true
    _avg?: FreelancerSkillAvgAggregateInputType
    _sum?: FreelancerSkillSumAggregateInputType
    _min?: FreelancerSkillMinAggregateInputType
    _max?: FreelancerSkillMaxAggregateInputType
  }

  export type FreelancerSkillGroupByOutputType = {
    id: string
    freelancerId: string
    skillId: string
    yearsExperience: number
    createdAt: Date
    updatedAt: Date
    _count: FreelancerSkillCountAggregateOutputType | null
    _avg: FreelancerSkillAvgAggregateOutputType | null
    _sum: FreelancerSkillSumAggregateOutputType | null
    _min: FreelancerSkillMinAggregateOutputType | null
    _max: FreelancerSkillMaxAggregateOutputType | null
  }

  type GetFreelancerSkillGroupByPayload<T extends FreelancerSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelancerSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelancerSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelancerSkillGroupByOutputType[P]>
            : GetScalarType<T[P], FreelancerSkillGroupByOutputType[P]>
        }
      >
    >


  export type FreelancerSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    freelancerId?: boolean
    skillId?: boolean
    yearsExperience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancer?: boolean | FreelancerProfileDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerSkill"]>

  export type FreelancerSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    freelancerId?: boolean
    skillId?: boolean
    yearsExperience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancer?: boolean | FreelancerProfileDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerSkill"]>

  export type FreelancerSkillSelectScalar = {
    id?: boolean
    freelancerId?: boolean
    skillId?: boolean
    yearsExperience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelancerSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancer?: boolean | FreelancerProfileDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type FreelancerSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancer?: boolean | FreelancerProfileDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $FreelancerSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelancerSkill"
    objects: {
      freelancer: Prisma.$FreelancerProfilePayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      freelancerId: string
      skillId: string
      yearsExperience: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelancerSkill"]>
    composites: {}
  }

  type FreelancerSkillGetPayload<S extends boolean | null | undefined | FreelancerSkillDefaultArgs> = $Result.GetResult<Prisma.$FreelancerSkillPayload, S>

  type FreelancerSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FreelancerSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FreelancerSkillCountAggregateInputType | true
    }

  export interface FreelancerSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelancerSkill'], meta: { name: 'FreelancerSkill' } }
    /**
     * Find zero or one FreelancerSkill that matches the filter.
     * @param {FreelancerSkillFindUniqueArgs} args - Arguments to find a FreelancerSkill
     * @example
     * // Get one FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelancerSkillFindUniqueArgs>(args: SelectSubset<T, FreelancerSkillFindUniqueArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FreelancerSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FreelancerSkillFindUniqueOrThrowArgs} args - Arguments to find a FreelancerSkill
     * @example
     * // Get one FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelancerSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelancerSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FreelancerSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillFindFirstArgs} args - Arguments to find a FreelancerSkill
     * @example
     * // Get one FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelancerSkillFindFirstArgs>(args?: SelectSubset<T, FreelancerSkillFindFirstArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FreelancerSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillFindFirstOrThrowArgs} args - Arguments to find a FreelancerSkill
     * @example
     * // Get one FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelancerSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelancerSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FreelancerSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelancerSkills
     * const freelancerSkills = await prisma.freelancerSkill.findMany()
     * 
     * // Get first 10 FreelancerSkills
     * const freelancerSkills = await prisma.freelancerSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelancerSkillWithIdOnly = await prisma.freelancerSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelancerSkillFindManyArgs>(args?: SelectSubset<T, FreelancerSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FreelancerSkill.
     * @param {FreelancerSkillCreateArgs} args - Arguments to create a FreelancerSkill.
     * @example
     * // Create one FreelancerSkill
     * const FreelancerSkill = await prisma.freelancerSkill.create({
     *   data: {
     *     // ... data to create a FreelancerSkill
     *   }
     * })
     * 
     */
    create<T extends FreelancerSkillCreateArgs>(args: SelectSubset<T, FreelancerSkillCreateArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FreelancerSkills.
     * @param {FreelancerSkillCreateManyArgs} args - Arguments to create many FreelancerSkills.
     * @example
     * // Create many FreelancerSkills
     * const freelancerSkill = await prisma.freelancerSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelancerSkillCreateManyArgs>(args?: SelectSubset<T, FreelancerSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelancerSkills and returns the data saved in the database.
     * @param {FreelancerSkillCreateManyAndReturnArgs} args - Arguments to create many FreelancerSkills.
     * @example
     * // Create many FreelancerSkills
     * const freelancerSkill = await prisma.freelancerSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelancerSkills and only return the `id`
     * const freelancerSkillWithIdOnly = await prisma.freelancerSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelancerSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelancerSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FreelancerSkill.
     * @param {FreelancerSkillDeleteArgs} args - Arguments to delete one FreelancerSkill.
     * @example
     * // Delete one FreelancerSkill
     * const FreelancerSkill = await prisma.freelancerSkill.delete({
     *   where: {
     *     // ... filter to delete one FreelancerSkill
     *   }
     * })
     * 
     */
    delete<T extends FreelancerSkillDeleteArgs>(args: SelectSubset<T, FreelancerSkillDeleteArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FreelancerSkill.
     * @param {FreelancerSkillUpdateArgs} args - Arguments to update one FreelancerSkill.
     * @example
     * // Update one FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelancerSkillUpdateArgs>(args: SelectSubset<T, FreelancerSkillUpdateArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FreelancerSkills.
     * @param {FreelancerSkillDeleteManyArgs} args - Arguments to filter FreelancerSkills to delete.
     * @example
     * // Delete a few FreelancerSkills
     * const { count } = await prisma.freelancerSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelancerSkillDeleteManyArgs>(args?: SelectSubset<T, FreelancerSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelancerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelancerSkills
     * const freelancerSkill = await prisma.freelancerSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelancerSkillUpdateManyArgs>(args: SelectSubset<T, FreelancerSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FreelancerSkill.
     * @param {FreelancerSkillUpsertArgs} args - Arguments to update or create a FreelancerSkill.
     * @example
     * // Update or create a FreelancerSkill
     * const freelancerSkill = await prisma.freelancerSkill.upsert({
     *   create: {
     *     // ... data to create a FreelancerSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelancerSkill we want to update
     *   }
     * })
     */
    upsert<T extends FreelancerSkillUpsertArgs>(args: SelectSubset<T, FreelancerSkillUpsertArgs<ExtArgs>>): Prisma__FreelancerSkillClient<$Result.GetResult<Prisma.$FreelancerSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FreelancerSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillCountArgs} args - Arguments to filter FreelancerSkills to count.
     * @example
     * // Count the number of FreelancerSkills
     * const count = await prisma.freelancerSkill.count({
     *   where: {
     *     // ... the filter for the FreelancerSkills we want to count
     *   }
     * })
    **/
    count<T extends FreelancerSkillCountArgs>(
      args?: Subset<T, FreelancerSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelancerSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelancerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelancerSkillAggregateArgs>(args: Subset<T, FreelancerSkillAggregateArgs>): Prisma.PrismaPromise<GetFreelancerSkillAggregateType<T>>

    /**
     * Group by FreelancerSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelancerSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelancerSkillGroupByArgs['orderBy'] }
        : { orderBy?: FreelancerSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelancerSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelancerSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelancerSkill model
   */
  readonly fields: FreelancerSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelancerSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelancerSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    freelancer<T extends FreelancerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FreelancerProfileDefaultArgs<ExtArgs>>): Prisma__FreelancerProfileClient<$Result.GetResult<Prisma.$FreelancerProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelancerSkill model
   */ 
  interface FreelancerSkillFieldRefs {
    readonly id: FieldRef<"FreelancerSkill", 'String'>
    readonly freelancerId: FieldRef<"FreelancerSkill", 'String'>
    readonly skillId: FieldRef<"FreelancerSkill", 'String'>
    readonly yearsExperience: FieldRef<"FreelancerSkill", 'Int'>
    readonly createdAt: FieldRef<"FreelancerSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelancerSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelancerSkill findUnique
   */
  export type FreelancerSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerSkill to fetch.
     */
    where: FreelancerSkillWhereUniqueInput
  }

  /**
   * FreelancerSkill findUniqueOrThrow
   */
  export type FreelancerSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerSkill to fetch.
     */
    where: FreelancerSkillWhereUniqueInput
  }

  /**
   * FreelancerSkill findFirst
   */
  export type FreelancerSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerSkill to fetch.
     */
    where?: FreelancerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerSkills to fetch.
     */
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerSkills.
     */
    cursor?: FreelancerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerSkills.
     */
    distinct?: FreelancerSkillScalarFieldEnum | FreelancerSkillScalarFieldEnum[]
  }

  /**
   * FreelancerSkill findFirstOrThrow
   */
  export type FreelancerSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerSkill to fetch.
     */
    where?: FreelancerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerSkills to fetch.
     */
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerSkills.
     */
    cursor?: FreelancerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerSkills.
     */
    distinct?: FreelancerSkillScalarFieldEnum | FreelancerSkillScalarFieldEnum[]
  }

  /**
   * FreelancerSkill findMany
   */
  export type FreelancerSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerSkills to fetch.
     */
    where?: FreelancerSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerSkills to fetch.
     */
    orderBy?: FreelancerSkillOrderByWithRelationInput | FreelancerSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelancerSkills.
     */
    cursor?: FreelancerSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerSkills.
     */
    skip?: number
    distinct?: FreelancerSkillScalarFieldEnum | FreelancerSkillScalarFieldEnum[]
  }

  /**
   * FreelancerSkill create
   */
  export type FreelancerSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelancerSkill.
     */
    data: XOR<FreelancerSkillCreateInput, FreelancerSkillUncheckedCreateInput>
  }

  /**
   * FreelancerSkill createMany
   */
  export type FreelancerSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelancerSkills.
     */
    data: FreelancerSkillCreateManyInput | FreelancerSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelancerSkill createManyAndReturn
   */
  export type FreelancerSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FreelancerSkills.
     */
    data: FreelancerSkillCreateManyInput | FreelancerSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelancerSkill update
   */
  export type FreelancerSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelancerSkill.
     */
    data: XOR<FreelancerSkillUpdateInput, FreelancerSkillUncheckedUpdateInput>
    /**
     * Choose, which FreelancerSkill to update.
     */
    where: FreelancerSkillWhereUniqueInput
  }

  /**
   * FreelancerSkill updateMany
   */
  export type FreelancerSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelancerSkills.
     */
    data: XOR<FreelancerSkillUpdateManyMutationInput, FreelancerSkillUncheckedUpdateManyInput>
    /**
     * Filter which FreelancerSkills to update
     */
    where?: FreelancerSkillWhereInput
  }

  /**
   * FreelancerSkill upsert
   */
  export type FreelancerSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelancerSkill to update in case it exists.
     */
    where: FreelancerSkillWhereUniqueInput
    /**
     * In case the FreelancerSkill found by the `where` argument doesn't exist, create a new FreelancerSkill with this data.
     */
    create: XOR<FreelancerSkillCreateInput, FreelancerSkillUncheckedCreateInput>
    /**
     * In case the FreelancerSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelancerSkillUpdateInput, FreelancerSkillUncheckedUpdateInput>
  }

  /**
   * FreelancerSkill delete
   */
  export type FreelancerSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
    /**
     * Filter which FreelancerSkill to delete.
     */
    where: FreelancerSkillWhereUniqueInput
  }

  /**
   * FreelancerSkill deleteMany
   */
  export type FreelancerSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerSkills to delete
     */
    where?: FreelancerSkillWhereInput
  }

  /**
   * FreelancerSkill without action
   */
  export type FreelancerSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerSkill
     */
    select?: FreelancerSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerSkillInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    budget: number | null
  }

  export type ProjectSumAggregateOutputType = {
    budget: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    title: string | null
    description: string | null
    budget: number | null
    deadline: Date | null
    status: $Enums.ProjectStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    title: string | null
    description: string | null
    budget: number | null
    deadline: Date | null
    status: $Enums.ProjectStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    clientId: number
    title: number
    description: number
    budget: number
    deadline: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    budget?: true
  }

  export type ProjectSumAggregateInputType = {
    budget?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    budget?: true
    deadline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    budget?: true
    deadline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    clientId?: true
    title?: true
    description?: true
    budget?: true
    deadline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date
    status: $Enums.ProjectStatus
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    budget?: boolean
    deadline?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    bids?: boolean | Project$bidsArgs<ExtArgs>
    messages?: boolean | Project$messagesArgs<ExtArgs>
    contract?: boolean | Project$contractArgs<ExtArgs>
    adminActions?: boolean | Project$adminActionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    budget?: boolean
    deadline?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    budget?: boolean
    deadline?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    bids?: boolean | Project$bidsArgs<ExtArgs>
    messages?: boolean | Project$messagesArgs<ExtArgs>
    contract?: boolean | Project$contractArgs<ExtArgs>
    adminActions?: boolean | Project$adminActionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$UserPayload<ExtArgs>
      skills: Prisma.$ProjectSkillPayload<ExtArgs>[]
      bids: Prisma.$BidPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      contract: Prisma.$ContractPayload<ExtArgs> | null
      adminActions: Prisma.$AdminActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      title: string
      description: string
      budget: number
      deadline: Date
      status: $Enums.ProjectStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skills<T extends Project$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Project$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany"> | Null>
    bids<T extends Project$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Project$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Project$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    contract<T extends Project$contractArgs<ExtArgs> = {}>(args?: Subset<T, Project$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminActions<T extends Project$adminActionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$adminActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly budget: FieldRef<"Project", 'Float'>
    readonly deadline: FieldRef<"Project", 'DateTime'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.skills
   */
  export type Project$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    cursor?: ProjectSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * Project.bids
   */
  export type Project$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Project.messages
   */
  export type Project$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Project.contract
   */
  export type Project$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Project.adminActions
   */
  export type Project$adminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    cursor?: AdminActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSkill
   */

  export type AggregateProjectSkill = {
    _count: ProjectSkillCountAggregateOutputType | null
    _min: ProjectSkillMinAggregateOutputType | null
    _max: ProjectSkillMaxAggregateOutputType | null
  }

  export type ProjectSkillMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    skillId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectSkillMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    skillId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectSkillCountAggregateOutputType = {
    id: number
    projectId: number
    skillId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectSkillMinAggregateInputType = {
    id?: true
    projectId?: true
    skillId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectSkillMaxAggregateInputType = {
    id?: true
    projectId?: true
    skillId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectSkillCountAggregateInputType = {
    id?: true
    projectId?: true
    skillId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSkill to aggregate.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSkills
    **/
    _count?: true | ProjectSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSkillMaxAggregateInputType
  }

  export type GetProjectSkillAggregateType<T extends ProjectSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSkill[P]>
      : GetScalarType<T[P], AggregateProjectSkill[P]>
  }




  export type ProjectSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSkillWhereInput
    orderBy?: ProjectSkillOrderByWithAggregationInput | ProjectSkillOrderByWithAggregationInput[]
    by: ProjectSkillScalarFieldEnum[] | ProjectSkillScalarFieldEnum
    having?: ProjectSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSkillCountAggregateInputType | true
    _min?: ProjectSkillMinAggregateInputType
    _max?: ProjectSkillMaxAggregateInputType
  }

  export type ProjectSkillGroupByOutputType = {
    id: string
    projectId: string
    skillId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectSkillCountAggregateOutputType | null
    _min: ProjectSkillMinAggregateOutputType | null
    _max: ProjectSkillMaxAggregateOutputType | null
  }

  type GetProjectSkillGroupByPayload<T extends ProjectSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSkillGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    skillId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSkill"]>

  export type ProjectSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    skillId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSkill"]>

  export type ProjectSkillSelectScalar = {
    id?: boolean
    projectId?: boolean
    skillId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ProjectSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $ProjectSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSkill"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      skillId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectSkill"]>
    composites: {}
  }

  type ProjectSkillGetPayload<S extends boolean | null | undefined | ProjectSkillDefaultArgs> = $Result.GetResult<Prisma.$ProjectSkillPayload, S>

  type ProjectSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectSkillCountAggregateInputType | true
    }

  export interface ProjectSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSkill'], meta: { name: 'ProjectSkill' } }
    /**
     * Find zero or one ProjectSkill that matches the filter.
     * @param {ProjectSkillFindUniqueArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSkillFindUniqueArgs>(args: SelectSubset<T, ProjectSkillFindUniqueArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectSkillFindUniqueOrThrowArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindFirstArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSkillFindFirstArgs>(args?: SelectSubset<T, ProjectSkillFindFirstArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindFirstOrThrowArgs} args - Arguments to find a ProjectSkill
     * @example
     * // Get one ProjectSkill
     * const projectSkill = await prisma.projectSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSkills
     * const projectSkills = await prisma.projectSkill.findMany()
     * 
     * // Get first 10 ProjectSkills
     * const projectSkills = await prisma.projectSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectSkillWithIdOnly = await prisma.projectSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectSkillFindManyArgs>(args?: SelectSubset<T, ProjectSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectSkill.
     * @param {ProjectSkillCreateArgs} args - Arguments to create a ProjectSkill.
     * @example
     * // Create one ProjectSkill
     * const ProjectSkill = await prisma.projectSkill.create({
     *   data: {
     *     // ... data to create a ProjectSkill
     *   }
     * })
     * 
     */
    create<T extends ProjectSkillCreateArgs>(args: SelectSubset<T, ProjectSkillCreateArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectSkills.
     * @param {ProjectSkillCreateManyArgs} args - Arguments to create many ProjectSkills.
     * @example
     * // Create many ProjectSkills
     * const projectSkill = await prisma.projectSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSkillCreateManyArgs>(args?: SelectSubset<T, ProjectSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectSkills and returns the data saved in the database.
     * @param {ProjectSkillCreateManyAndReturnArgs} args - Arguments to create many ProjectSkills.
     * @example
     * // Create many ProjectSkills
     * const projectSkill = await prisma.projectSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectSkills and only return the `id`
     * const projectSkillWithIdOnly = await prisma.projectSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectSkill.
     * @param {ProjectSkillDeleteArgs} args - Arguments to delete one ProjectSkill.
     * @example
     * // Delete one ProjectSkill
     * const ProjectSkill = await prisma.projectSkill.delete({
     *   where: {
     *     // ... filter to delete one ProjectSkill
     *   }
     * })
     * 
     */
    delete<T extends ProjectSkillDeleteArgs>(args: SelectSubset<T, ProjectSkillDeleteArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectSkill.
     * @param {ProjectSkillUpdateArgs} args - Arguments to update one ProjectSkill.
     * @example
     * // Update one ProjectSkill
     * const projectSkill = await prisma.projectSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSkillUpdateArgs>(args: SelectSubset<T, ProjectSkillUpdateArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectSkills.
     * @param {ProjectSkillDeleteManyArgs} args - Arguments to filter ProjectSkills to delete.
     * @example
     * // Delete a few ProjectSkills
     * const { count } = await prisma.projectSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSkillDeleteManyArgs>(args?: SelectSubset<T, ProjectSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSkills
     * const projectSkill = await prisma.projectSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSkillUpdateManyArgs>(args: SelectSubset<T, ProjectSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectSkill.
     * @param {ProjectSkillUpsertArgs} args - Arguments to update or create a ProjectSkill.
     * @example
     * // Update or create a ProjectSkill
     * const projectSkill = await prisma.projectSkill.upsert({
     *   create: {
     *     // ... data to create a ProjectSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSkill we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSkillUpsertArgs>(args: SelectSubset<T, ProjectSkillUpsertArgs<ExtArgs>>): Prisma__ProjectSkillClient<$Result.GetResult<Prisma.$ProjectSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillCountArgs} args - Arguments to filter ProjectSkills to count.
     * @example
     * // Count the number of ProjectSkills
     * const count = await prisma.projectSkill.count({
     *   where: {
     *     // ... the filter for the ProjectSkills we want to count
     *   }
     * })
    **/
    count<T extends ProjectSkillCountArgs>(
      args?: Subset<T, ProjectSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSkillAggregateArgs>(args: Subset<T, ProjectSkillAggregateArgs>): Prisma.PrismaPromise<GetProjectSkillAggregateType<T>>

    /**
     * Group by ProjectSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSkillGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSkill model
   */
  readonly fields: ProjectSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSkill model
   */ 
  interface ProjectSkillFieldRefs {
    readonly id: FieldRef<"ProjectSkill", 'String'>
    readonly projectId: FieldRef<"ProjectSkill", 'String'>
    readonly skillId: FieldRef<"ProjectSkill", 'String'>
    readonly createdAt: FieldRef<"ProjectSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSkill findUnique
   */
  export type ProjectSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill findUniqueOrThrow
   */
  export type ProjectSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill findFirst
   */
  export type ProjectSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSkills.
     */
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill findFirstOrThrow
   */
  export type ProjectSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkill to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSkills.
     */
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill findMany
   */
  export type ProjectSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSkills to fetch.
     */
    where?: ProjectSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSkills to fetch.
     */
    orderBy?: ProjectSkillOrderByWithRelationInput | ProjectSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSkills.
     */
    cursor?: ProjectSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSkills.
     */
    skip?: number
    distinct?: ProjectSkillScalarFieldEnum | ProjectSkillScalarFieldEnum[]
  }

  /**
   * ProjectSkill create
   */
  export type ProjectSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSkill.
     */
    data: XOR<ProjectSkillCreateInput, ProjectSkillUncheckedCreateInput>
  }

  /**
   * ProjectSkill createMany
   */
  export type ProjectSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSkills.
     */
    data: ProjectSkillCreateManyInput | ProjectSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSkill createManyAndReturn
   */
  export type ProjectSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectSkills.
     */
    data: ProjectSkillCreateManyInput | ProjectSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSkill update
   */
  export type ProjectSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSkill.
     */
    data: XOR<ProjectSkillUpdateInput, ProjectSkillUncheckedUpdateInput>
    /**
     * Choose, which ProjectSkill to update.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill updateMany
   */
  export type ProjectSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSkills.
     */
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSkills to update
     */
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectSkill upsert
   */
  export type ProjectSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSkill to update in case it exists.
     */
    where: ProjectSkillWhereUniqueInput
    /**
     * In case the ProjectSkill found by the `where` argument doesn't exist, create a new ProjectSkill with this data.
     */
    create: XOR<ProjectSkillCreateInput, ProjectSkillUncheckedCreateInput>
    /**
     * In case the ProjectSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSkillUpdateInput, ProjectSkillUncheckedUpdateInput>
  }

  /**
   * ProjectSkill delete
   */
  export type ProjectSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
    /**
     * Filter which ProjectSkill to delete.
     */
    where: ProjectSkillWhereUniqueInput
  }

  /**
   * ProjectSkill deleteMany
   */
  export type ProjectSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSkills to delete
     */
    where?: ProjectSkillWhereInput
  }

  /**
   * ProjectSkill without action
   */
  export type ProjectSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSkill
     */
    select?: ProjectSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSkillInclude<ExtArgs> | null
  }


  /**
   * Model Bid
   */

  export type AggregateBid = {
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  export type BidAvgAggregateOutputType = {
    amount: number | null
    duration: number | null
  }

  export type BidSumAggregateOutputType = {
    amount: number | null
    duration: number | null
  }

  export type BidMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    freelancerId: string | null
    amount: number | null
    duration: number | null
    coverLetter: string | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    freelancerId: string | null
    amount: number | null
    duration: number | null
    coverLetter: string | null
    status: $Enums.BidStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidCountAggregateOutputType = {
    id: number
    projectId: number
    freelancerId: number
    amount: number
    duration: number
    coverLetter: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidAvgAggregateInputType = {
    amount?: true
    duration?: true
  }

  export type BidSumAggregateInputType = {
    amount?: true
    duration?: true
  }

  export type BidMinAggregateInputType = {
    id?: true
    projectId?: true
    freelancerId?: true
    amount?: true
    duration?: true
    coverLetter?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidMaxAggregateInputType = {
    id?: true
    projectId?: true
    freelancerId?: true
    amount?: true
    duration?: true
    coverLetter?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidCountAggregateInputType = {
    id?: true
    projectId?: true
    freelancerId?: true
    amount?: true
    duration?: true
    coverLetter?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bid to aggregate.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bids
    **/
    _count?: true | BidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidMaxAggregateInputType
  }

  export type GetBidAggregateType<T extends BidAggregateArgs> = {
        [P in keyof T & keyof AggregateBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBid[P]>
      : GetScalarType<T[P], AggregateBid[P]>
  }




  export type BidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
    orderBy?: BidOrderByWithAggregationInput | BidOrderByWithAggregationInput[]
    by: BidScalarFieldEnum[] | BidScalarFieldEnum
    having?: BidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidCountAggregateInputType | true
    _avg?: BidAvgAggregateInputType
    _sum?: BidSumAggregateInputType
    _min?: BidMinAggregateInputType
    _max?: BidMaxAggregateInputType
  }

  export type BidGroupByOutputType = {
    id: string
    projectId: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status: $Enums.BidStatus
    createdAt: Date
    updatedAt: Date
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  type GetBidGroupByPayload<T extends BidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidGroupByOutputType[P]>
            : GetScalarType<T[P], BidGroupByOutputType[P]>
        }
      >
    >


  export type BidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    freelancerId?: boolean
    amount?: boolean
    duration?: boolean
    coverLetter?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    contract?: boolean | Bid$contractArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    freelancerId?: boolean
    amount?: boolean
    duration?: boolean
    coverLetter?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectScalar = {
    id?: boolean
    projectId?: boolean
    freelancerId?: boolean
    amount?: boolean
    duration?: boolean
    coverLetter?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    contract?: boolean | Bid$contractArgs<ExtArgs>
  }
  export type BidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bid"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      freelancer: Prisma.$UserPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      freelancerId: string
      amount: number
      duration: number
      coverLetter: string
      status: $Enums.BidStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bid"]>
    composites: {}
  }

  type BidGetPayload<S extends boolean | null | undefined | BidDefaultArgs> = $Result.GetResult<Prisma.$BidPayload, S>

  type BidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BidFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BidCountAggregateInputType | true
    }

  export interface BidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bid'], meta: { name: 'Bid' } }
    /**
     * Find zero or one Bid that matches the filter.
     * @param {BidFindUniqueArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidFindUniqueArgs>(args: SelectSubset<T, BidFindUniqueArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bid that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BidFindUniqueOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidFindUniqueOrThrowArgs>(args: SelectSubset<T, BidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidFindFirstArgs>(args?: SelectSubset<T, BidFindFirstArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidFindFirstOrThrowArgs>(args?: SelectSubset<T, BidFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bids
     * const bids = await prisma.bid.findMany()
     * 
     * // Get first 10 Bids
     * const bids = await prisma.bid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidWithIdOnly = await prisma.bid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidFindManyArgs>(args?: SelectSubset<T, BidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bid.
     * @param {BidCreateArgs} args - Arguments to create a Bid.
     * @example
     * // Create one Bid
     * const Bid = await prisma.bid.create({
     *   data: {
     *     // ... data to create a Bid
     *   }
     * })
     * 
     */
    create<T extends BidCreateArgs>(args: SelectSubset<T, BidCreateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bids.
     * @param {BidCreateManyArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidCreateManyArgs>(args?: SelectSubset<T, BidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bids and returns the data saved in the database.
     * @param {BidCreateManyAndReturnArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidCreateManyAndReturnArgs>(args?: SelectSubset<T, BidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bid.
     * @param {BidDeleteArgs} args - Arguments to delete one Bid.
     * @example
     * // Delete one Bid
     * const Bid = await prisma.bid.delete({
     *   where: {
     *     // ... filter to delete one Bid
     *   }
     * })
     * 
     */
    delete<T extends BidDeleteArgs>(args: SelectSubset<T, BidDeleteArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bid.
     * @param {BidUpdateArgs} args - Arguments to update one Bid.
     * @example
     * // Update one Bid
     * const bid = await prisma.bid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidUpdateArgs>(args: SelectSubset<T, BidUpdateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bids.
     * @param {BidDeleteManyArgs} args - Arguments to filter Bids to delete.
     * @example
     * // Delete a few Bids
     * const { count } = await prisma.bid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidDeleteManyArgs>(args?: SelectSubset<T, BidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidUpdateManyArgs>(args: SelectSubset<T, BidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bid.
     * @param {BidUpsertArgs} args - Arguments to update or create a Bid.
     * @example
     * // Update or create a Bid
     * const bid = await prisma.bid.upsert({
     *   create: {
     *     // ... data to create a Bid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bid we want to update
     *   }
     * })
     */
    upsert<T extends BidUpsertArgs>(args: SelectSubset<T, BidUpsertArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidCountArgs} args - Arguments to filter Bids to count.
     * @example
     * // Count the number of Bids
     * const count = await prisma.bid.count({
     *   where: {
     *     // ... the filter for the Bids we want to count
     *   }
     * })
    **/
    count<T extends BidCountArgs>(
      args?: Subset<T, BidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidAggregateArgs>(args: Subset<T, BidAggregateArgs>): Prisma.PrismaPromise<GetBidAggregateType<T>>

    /**
     * Group by Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidGroupByArgs['orderBy'] }
        : { orderBy?: BidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bid model
   */
  readonly fields: BidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    freelancer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contract<T extends Bid$contractArgs<ExtArgs> = {}>(args?: Subset<T, Bid$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bid model
   */ 
  interface BidFieldRefs {
    readonly id: FieldRef<"Bid", 'String'>
    readonly projectId: FieldRef<"Bid", 'String'>
    readonly freelancerId: FieldRef<"Bid", 'String'>
    readonly amount: FieldRef<"Bid", 'Float'>
    readonly duration: FieldRef<"Bid", 'Int'>
    readonly coverLetter: FieldRef<"Bid", 'String'>
    readonly status: FieldRef<"Bid", 'BidStatus'>
    readonly createdAt: FieldRef<"Bid", 'DateTime'>
    readonly updatedAt: FieldRef<"Bid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bid findUnique
   */
  export type BidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findUniqueOrThrow
   */
  export type BidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findFirst
   */
  export type BidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findFirstOrThrow
   */
  export type BidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findMany
   */
  export type BidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bids to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid create
   */
  export type BidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to create a Bid.
     */
    data: XOR<BidCreateInput, BidUncheckedCreateInput>
  }

  /**
   * Bid createMany
   */
  export type BidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bid createManyAndReturn
   */
  export type BidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid update
   */
  export type BidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to update a Bid.
     */
    data: XOR<BidUpdateInput, BidUncheckedUpdateInput>
    /**
     * Choose, which Bid to update.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid updateMany
   */
  export type BidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
  }

  /**
   * Bid upsert
   */
  export type BidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The filter to search for the Bid to update in case it exists.
     */
    where: BidWhereUniqueInput
    /**
     * In case the Bid found by the `where` argument doesn't exist, create a new Bid with this data.
     */
    create: XOR<BidCreateInput, BidUncheckedCreateInput>
    /**
     * In case the Bid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidUpdateInput, BidUncheckedUpdateInput>
  }

  /**
   * Bid delete
   */
  export type BidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter which Bid to delete.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid deleteMany
   */
  export type BidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bids to delete
     */
    where?: BidWhereInput
  }

  /**
   * Bid.contract
   */
  export type Bid$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Bid without action
   */
  export type BidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    amount: number | null
  }

  export type ContractSumAggregateOutputType = {
    amount: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    bidId: string | null
    clientId: string | null
    freelancerId: string | null
    terms: string | null
    amount: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ContractStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    bidId: string | null
    clientId: string | null
    freelancerId: string | null
    terms: string | null
    amount: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ContractStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    projectId: number
    bidId: number
    clientId: number
    freelancerId: number
    terms: number
    amount: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    amount?: true
  }

  export type ContractSumAggregateInputType = {
    amount?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    projectId?: true
    bidId?: true
    clientId?: true
    freelancerId?: true
    terms?: true
    amount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    projectId?: true
    bidId?: true
    clientId?: true
    freelancerId?: true
    terms?: true
    amount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    projectId?: true
    bidId?: true
    clientId?: true
    freelancerId?: true
    terms?: true
    amount?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    projectId: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date
    endDate: Date | null
    status: $Enums.ContractStatus
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    bidId?: boolean
    clientId?: boolean
    freelancerId?: boolean
    terms?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    bid?: boolean | BidDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Contract$paymentsArgs<ExtArgs>
    reviews?: boolean | Contract$reviewsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    bidId?: boolean
    clientId?: boolean
    freelancerId?: boolean
    terms?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    bid?: boolean | BidDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    projectId?: boolean
    bidId?: boolean
    clientId?: boolean
    freelancerId?: boolean
    terms?: boolean
    amount?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    bid?: boolean | BidDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Contract$paymentsArgs<ExtArgs>
    reviews?: boolean | Contract$reviewsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    bid?: boolean | BidDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      bid: Prisma.$BidPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
      freelancer: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      bidId: string
      clientId: string
      freelancerId: string
      terms: string
      amount: number
      startDate: Date
      endDate: Date | null
      status: $Enums.ContractStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bid<T extends BidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BidDefaultArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    freelancer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Contract$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Contract$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly projectId: FieldRef<"Contract", 'String'>
    readonly bidId: FieldRef<"Contract", 'String'>
    readonly clientId: FieldRef<"Contract", 'String'>
    readonly freelancerId: FieldRef<"Contract", 'String'>
    readonly terms: FieldRef<"Contract", 'String'>
    readonly amount: FieldRef<"Contract", 'Float'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly status: FieldRef<"Contract", 'ContractStatus'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract.payments
   */
  export type Contract$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Contract.reviews
   */
  export type Contract$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    amount: number | null
    description: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    amount: number | null
    description: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    contractId: number
    amount: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    contractId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    contractId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    contractId?: true
    amount?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    contractId: string
    amount: number
    description: string
    status: $Enums.PaymentStatus
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    contractId?: boolean
    amount?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      amount: number
      description: string
      status: $Enums.PaymentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly contractId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    projectId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    projectId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    projectId: number
    content: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    projectId?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    projectId?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    projectId?: true
    content?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    projectId: string | null
    content: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    projectId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Message$projectArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    projectId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Message$projectArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    projectId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Message$projectArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Message$projectArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      projectId: string | null
      content: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Message$projectArgs<ExtArgs> = {}>(args?: Subset<T, Message$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly projectId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.project
   */
  export type Message$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    fromUserId: string | null
    toUserId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    fromUserId: string | null
    toUserId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    contractId: number
    fromUserId: number
    toUserId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    contractId?: true
    fromUserId?: true
    toUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    contractId?: true
    fromUserId?: true
    toUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    contractId?: true
    fromUserId?: true
    toUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    contractId: string
    fromUserId: string
    toUserId: string
    rating: number
    comment: string
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    contractId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      fromUserId: string
      toUserId: string
      rating: number
      comment: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly contractId: FieldRef<"Review", 'String'>
    readonly fromUserId: FieldRef<"Review", 'String'>
    readonly toUserId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AdminAction
   */

  export type AggregateAdminAction = {
    _count: AdminActionCountAggregateOutputType | null
    _min: AdminActionMinAggregateOutputType | null
    _max: AdminActionMaxAggregateOutputType | null
  }

  export type AdminActionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    userId: string | null
    projectId: string | null
    action: $Enums.AdminActionType | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminActionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    userId: string | null
    projectId: string | null
    action: $Enums.AdminActionType | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminActionCountAggregateOutputType = {
    id: number
    adminId: number
    userId: number
    projectId: number
    action: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminActionMinAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    projectId?: true
    action?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminActionMaxAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    projectId?: true
    action?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminActionCountAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    projectId?: true
    action?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAction to aggregate.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActions
    **/
    _count?: true | AdminActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActionMaxAggregateInputType
  }

  export type GetAdminActionAggregateType<T extends AdminActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAction[P]>
      : GetScalarType<T[P], AggregateAdminAction[P]>
  }




  export type AdminActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithAggregationInput | AdminActionOrderByWithAggregationInput[]
    by: AdminActionScalarFieldEnum[] | AdminActionScalarFieldEnum
    having?: AdminActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActionCountAggregateInputType | true
    _min?: AdminActionMinAggregateInputType
    _max?: AdminActionMaxAggregateInputType
  }

  export type AdminActionGroupByOutputType = {
    id: string
    adminId: string
    userId: string | null
    projectId: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt: Date
    updatedAt: Date
    _count: AdminActionCountAggregateOutputType | null
    _min: AdminActionMinAggregateOutputType | null
    _max: AdminActionMaxAggregateOutputType | null
  }

  type GetAdminActionGroupByPayload<T extends AdminActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActionGroupByOutputType[P]>
        }
      >
    >


  export type AdminActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    userId?: boolean
    projectId?: boolean
    action?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | AdminAction$userArgs<ExtArgs>
    project?: boolean | AdminAction$projectArgs<ExtArgs>
  }, ExtArgs["result"]["adminAction"]>

  export type AdminActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    userId?: boolean
    projectId?: boolean
    action?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | AdminAction$userArgs<ExtArgs>
    project?: boolean | AdminAction$projectArgs<ExtArgs>
  }, ExtArgs["result"]["adminAction"]>

  export type AdminActionSelectScalar = {
    id?: boolean
    adminId?: boolean
    userId?: boolean
    projectId?: boolean
    action?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | AdminAction$userArgs<ExtArgs>
    project?: boolean | AdminAction$projectArgs<ExtArgs>
  }
  export type AdminActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | AdminAction$userArgs<ExtArgs>
    project?: boolean | AdminAction$projectArgs<ExtArgs>
  }

  export type $AdminActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAction"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      userId: string | null
      projectId: string | null
      action: $Enums.AdminActionType
      reason: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminAction"]>
    composites: {}
  }

  type AdminActionGetPayload<S extends boolean | null | undefined | AdminActionDefaultArgs> = $Result.GetResult<Prisma.$AdminActionPayload, S>

  type AdminActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminActionCountAggregateInputType | true
    }

  export interface AdminActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAction'], meta: { name: 'AdminAction' } }
    /**
     * Find zero or one AdminAction that matches the filter.
     * @param {AdminActionFindUniqueArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActionFindUniqueArgs>(args: SelectSubset<T, AdminActionFindUniqueArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminActionFindUniqueOrThrowArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindFirstArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActionFindFirstArgs>(args?: SelectSubset<T, AdminActionFindFirstArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindFirstOrThrowArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActions
     * const adminActions = await prisma.adminAction.findMany()
     * 
     * // Get first 10 AdminActions
     * const adminActions = await prisma.adminAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActionWithIdOnly = await prisma.adminAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActionFindManyArgs>(args?: SelectSubset<T, AdminActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAction.
     * @param {AdminActionCreateArgs} args - Arguments to create a AdminAction.
     * @example
     * // Create one AdminAction
     * const AdminAction = await prisma.adminAction.create({
     *   data: {
     *     // ... data to create a AdminAction
     *   }
     * })
     * 
     */
    create<T extends AdminActionCreateArgs>(args: SelectSubset<T, AdminActionCreateArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminActions.
     * @param {AdminActionCreateManyArgs} args - Arguments to create many AdminActions.
     * @example
     * // Create many AdminActions
     * const adminAction = await prisma.adminAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActionCreateManyArgs>(args?: SelectSubset<T, AdminActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminActions and returns the data saved in the database.
     * @param {AdminActionCreateManyAndReturnArgs} args - Arguments to create many AdminActions.
     * @example
     * // Create many AdminActions
     * const adminAction = await prisma.adminAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminActions and only return the `id`
     * const adminActionWithIdOnly = await prisma.adminAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminActionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAction.
     * @param {AdminActionDeleteArgs} args - Arguments to delete one AdminAction.
     * @example
     * // Delete one AdminAction
     * const AdminAction = await prisma.adminAction.delete({
     *   where: {
     *     // ... filter to delete one AdminAction
     *   }
     * })
     * 
     */
    delete<T extends AdminActionDeleteArgs>(args: SelectSubset<T, AdminActionDeleteArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAction.
     * @param {AdminActionUpdateArgs} args - Arguments to update one AdminAction.
     * @example
     * // Update one AdminAction
     * const adminAction = await prisma.adminAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActionUpdateArgs>(args: SelectSubset<T, AdminActionUpdateArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminActions.
     * @param {AdminActionDeleteManyArgs} args - Arguments to filter AdminActions to delete.
     * @example
     * // Delete a few AdminActions
     * const { count } = await prisma.adminAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActionDeleteManyArgs>(args?: SelectSubset<T, AdminActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActions
     * const adminAction = await prisma.adminAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActionUpdateManyArgs>(args: SelectSubset<T, AdminActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAction.
     * @param {AdminActionUpsertArgs} args - Arguments to update or create a AdminAction.
     * @example
     * // Update or create a AdminAction
     * const adminAction = await prisma.adminAction.upsert({
     *   create: {
     *     // ... data to create a AdminAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAction we want to update
     *   }
     * })
     */
    upsert<T extends AdminActionUpsertArgs>(args: SelectSubset<T, AdminActionUpsertArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionCountArgs} args - Arguments to filter AdminActions to count.
     * @example
     * // Count the number of AdminActions
     * const count = await prisma.adminAction.count({
     *   where: {
     *     // ... the filter for the AdminActions we want to count
     *   }
     * })
    **/
    count<T extends AdminActionCountArgs>(
      args?: Subset<T, AdminActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActionAggregateArgs>(args: Subset<T, AdminActionAggregateArgs>): Prisma.PrismaPromise<GetAdminActionAggregateType<T>>

    /**
     * Group by AdminAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActionGroupByArgs['orderBy'] }
        : { orderBy?: AdminActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAction model
   */
  readonly fields: AdminActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends AdminAction$userArgs<ExtArgs> = {}>(args?: Subset<T, AdminAction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends AdminAction$projectArgs<ExtArgs> = {}>(args?: Subset<T, AdminAction$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAction model
   */ 
  interface AdminActionFieldRefs {
    readonly id: FieldRef<"AdminAction", 'String'>
    readonly adminId: FieldRef<"AdminAction", 'String'>
    readonly userId: FieldRef<"AdminAction", 'String'>
    readonly projectId: FieldRef<"AdminAction", 'String'>
    readonly action: FieldRef<"AdminAction", 'AdminActionType'>
    readonly reason: FieldRef<"AdminAction", 'String'>
    readonly createdAt: FieldRef<"AdminAction", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAction findUnique
   */
  export type AdminActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction findUniqueOrThrow
   */
  export type AdminActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction findFirst
   */
  export type AdminActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActions.
     */
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction findFirstOrThrow
   */
  export type AdminActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActions.
     */
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction findMany
   */
  export type AdminActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminActions to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction create
   */
  export type AdminActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAction.
     */
    data: XOR<AdminActionCreateInput, AdminActionUncheckedCreateInput>
  }

  /**
   * AdminAction createMany
   */
  export type AdminActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActions.
     */
    data: AdminActionCreateManyInput | AdminActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAction createManyAndReturn
   */
  export type AdminActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminActions.
     */
    data: AdminActionCreateManyInput | AdminActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAction update
   */
  export type AdminActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAction.
     */
    data: XOR<AdminActionUpdateInput, AdminActionUncheckedUpdateInput>
    /**
     * Choose, which AdminAction to update.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction updateMany
   */
  export type AdminActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActions.
     */
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyInput>
    /**
     * Filter which AdminActions to update
     */
    where?: AdminActionWhereInput
  }

  /**
   * AdminAction upsert
   */
  export type AdminActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAction to update in case it exists.
     */
    where: AdminActionWhereUniqueInput
    /**
     * In case the AdminAction found by the `where` argument doesn't exist, create a new AdminAction with this data.
     */
    create: XOR<AdminActionCreateInput, AdminActionUncheckedCreateInput>
    /**
     * In case the AdminAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActionUpdateInput, AdminActionUncheckedUpdateInput>
  }

  /**
   * AdminAction delete
   */
  export type AdminActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter which AdminAction to delete.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction deleteMany
   */
  export type AdminActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActions to delete
     */
    where?: AdminActionWhereInput
  }

  /**
   * AdminAction.user
   */
  export type AdminAction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AdminAction.project
   */
  export type AdminAction$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * AdminAction without action
   */
  export type AdminActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
  }


  /**
   * Model Gig
   */

  export type AggregateGig = {
    _count: GigCountAggregateOutputType | null
    _avg: GigAvgAggregateOutputType | null
    _sum: GigSumAggregateOutputType | null
    _min: GigMinAggregateOutputType | null
    _max: GigMaxAggregateOutputType | null
  }

  export type GigAvgAggregateOutputType = {
    price: number | null
    deliveryTime: number | null
    revisions: number | null
    rating: number | null
  }

  export type GigSumAggregateOutputType = {
    price: number | null
    deliveryTime: number | null
    revisions: number | null
    rating: number | null
  }

  export type GigMinAggregateOutputType = {
    id: string | null
    freelancerId: string | null
    title: string | null
    description: string | null
    price: number | null
    deliveryTime: number | null
    revisions: number | null
    category: string | null
    subcategory: string | null
    status: $Enums.GigStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigMaxAggregateOutputType = {
    id: string | null
    freelancerId: string | null
    title: string | null
    description: string | null
    price: number | null
    deliveryTime: number | null
    revisions: number | null
    category: string | null
    subcategory: string | null
    status: $Enums.GigStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigCountAggregateOutputType = {
    id: number
    freelancerId: number
    title: number
    description: number
    price: number
    deliveryTime: number
    revisions: number
    category: number
    subcategory: number
    tags: number
    images: number
    requirements: number
    status: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GigAvgAggregateInputType = {
    price?: true
    deliveryTime?: true
    revisions?: true
    rating?: true
  }

  export type GigSumAggregateInputType = {
    price?: true
    deliveryTime?: true
    revisions?: true
    rating?: true
  }

  export type GigMinAggregateInputType = {
    id?: true
    freelancerId?: true
    title?: true
    description?: true
    price?: true
    deliveryTime?: true
    revisions?: true
    category?: true
    subcategory?: true
    status?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigMaxAggregateInputType = {
    id?: true
    freelancerId?: true
    title?: true
    description?: true
    price?: true
    deliveryTime?: true
    revisions?: true
    category?: true
    subcategory?: true
    status?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigCountAggregateInputType = {
    id?: true
    freelancerId?: true
    title?: true
    description?: true
    price?: true
    deliveryTime?: true
    revisions?: true
    category?: true
    subcategory?: true
    tags?: true
    images?: true
    requirements?: true
    status?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gig to aggregate.
     */
    where?: GigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gigs to fetch.
     */
    orderBy?: GigOrderByWithRelationInput | GigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gigs
    **/
    _count?: true | GigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GigMaxAggregateInputType
  }

  export type GetGigAggregateType<T extends GigAggregateArgs> = {
        [P in keyof T & keyof AggregateGig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGig[P]>
      : GetScalarType<T[P], AggregateGig[P]>
  }




  export type GigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigWhereInput
    orderBy?: GigOrderByWithAggregationInput | GigOrderByWithAggregationInput[]
    by: GigScalarFieldEnum[] | GigScalarFieldEnum
    having?: GigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GigCountAggregateInputType | true
    _avg?: GigAvgAggregateInputType
    _sum?: GigSumAggregateInputType
    _min?: GigMinAggregateInputType
    _max?: GigMaxAggregateInputType
  }

  export type GigGroupByOutputType = {
    id: string
    freelancerId: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags: string[]
    images: string[]
    requirements: string[]
    status: $Enums.GigStatus
    rating: number
    createdAt: Date
    updatedAt: Date
    _count: GigCountAggregateOutputType | null
    _avg: GigAvgAggregateOutputType | null
    _sum: GigSumAggregateOutputType | null
    _min: GigMinAggregateOutputType | null
    _max: GigMaxAggregateOutputType | null
  }

  type GetGigGroupByPayload<T extends GigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GigGroupByOutputType[P]>
            : GetScalarType<T[P], GigGroupByOutputType[P]>
        }
      >
    >


  export type GigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    freelancerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    category?: boolean
    subcategory?: boolean
    tags?: boolean
    images?: boolean
    requirements?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Gig$reviewsArgs<ExtArgs>
    orders?: boolean | Gig$ordersArgs<ExtArgs>
    _count?: boolean | GigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gig"]>

  export type GigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    freelancerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    category?: boolean
    subcategory?: boolean
    tags?: boolean
    images?: boolean
    requirements?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gig"]>

  export type GigSelectScalar = {
    id?: boolean
    freelancerId?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    category?: boolean
    subcategory?: boolean
    tags?: boolean
    images?: boolean
    requirements?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Gig$reviewsArgs<ExtArgs>
    orders?: boolean | Gig$ordersArgs<ExtArgs>
    _count?: boolean | GigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    freelancer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gig"
    objects: {
      freelancer: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$GigReviewPayload<ExtArgs>[]
      orders: Prisma.$GigOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      freelancerId: string
      title: string
      description: string
      price: number
      deliveryTime: number
      revisions: number
      category: string
      subcategory: string
      tags: string[]
      images: string[]
      requirements: string[]
      status: $Enums.GigStatus
      rating: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gig"]>
    composites: {}
  }

  type GigGetPayload<S extends boolean | null | undefined | GigDefaultArgs> = $Result.GetResult<Prisma.$GigPayload, S>

  type GigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GigCountAggregateInputType | true
    }

  export interface GigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gig'], meta: { name: 'Gig' } }
    /**
     * Find zero or one Gig that matches the filter.
     * @param {GigFindUniqueArgs} args - Arguments to find a Gig
     * @example
     * // Get one Gig
     * const gig = await prisma.gig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GigFindUniqueArgs>(args: SelectSubset<T, GigFindUniqueArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GigFindUniqueOrThrowArgs} args - Arguments to find a Gig
     * @example
     * // Get one Gig
     * const gig = await prisma.gig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GigFindUniqueOrThrowArgs>(args: SelectSubset<T, GigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigFindFirstArgs} args - Arguments to find a Gig
     * @example
     * // Get one Gig
     * const gig = await prisma.gig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GigFindFirstArgs>(args?: SelectSubset<T, GigFindFirstArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigFindFirstOrThrowArgs} args - Arguments to find a Gig
     * @example
     * // Get one Gig
     * const gig = await prisma.gig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GigFindFirstOrThrowArgs>(args?: SelectSubset<T, GigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gigs
     * const gigs = await prisma.gig.findMany()
     * 
     * // Get first 10 Gigs
     * const gigs = await prisma.gig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gigWithIdOnly = await prisma.gig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GigFindManyArgs>(args?: SelectSubset<T, GigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gig.
     * @param {GigCreateArgs} args - Arguments to create a Gig.
     * @example
     * // Create one Gig
     * const Gig = await prisma.gig.create({
     *   data: {
     *     // ... data to create a Gig
     *   }
     * })
     * 
     */
    create<T extends GigCreateArgs>(args: SelectSubset<T, GigCreateArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gigs.
     * @param {GigCreateManyArgs} args - Arguments to create many Gigs.
     * @example
     * // Create many Gigs
     * const gig = await prisma.gig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GigCreateManyArgs>(args?: SelectSubset<T, GigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gigs and returns the data saved in the database.
     * @param {GigCreateManyAndReturnArgs} args - Arguments to create many Gigs.
     * @example
     * // Create many Gigs
     * const gig = await prisma.gig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gigs and only return the `id`
     * const gigWithIdOnly = await prisma.gig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GigCreateManyAndReturnArgs>(args?: SelectSubset<T, GigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gig.
     * @param {GigDeleteArgs} args - Arguments to delete one Gig.
     * @example
     * // Delete one Gig
     * const Gig = await prisma.gig.delete({
     *   where: {
     *     // ... filter to delete one Gig
     *   }
     * })
     * 
     */
    delete<T extends GigDeleteArgs>(args: SelectSubset<T, GigDeleteArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gig.
     * @param {GigUpdateArgs} args - Arguments to update one Gig.
     * @example
     * // Update one Gig
     * const gig = await prisma.gig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GigUpdateArgs>(args: SelectSubset<T, GigUpdateArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gigs.
     * @param {GigDeleteManyArgs} args - Arguments to filter Gigs to delete.
     * @example
     * // Delete a few Gigs
     * const { count } = await prisma.gig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GigDeleteManyArgs>(args?: SelectSubset<T, GigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gigs
     * const gig = await prisma.gig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GigUpdateManyArgs>(args: SelectSubset<T, GigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gig.
     * @param {GigUpsertArgs} args - Arguments to update or create a Gig.
     * @example
     * // Update or create a Gig
     * const gig = await prisma.gig.upsert({
     *   create: {
     *     // ... data to create a Gig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gig we want to update
     *   }
     * })
     */
    upsert<T extends GigUpsertArgs>(args: SelectSubset<T, GigUpsertArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigCountArgs} args - Arguments to filter Gigs to count.
     * @example
     * // Count the number of Gigs
     * const count = await prisma.gig.count({
     *   where: {
     *     // ... the filter for the Gigs we want to count
     *   }
     * })
    **/
    count<T extends GigCountArgs>(
      args?: Subset<T, GigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GigAggregateArgs>(args: Subset<T, GigAggregateArgs>): Prisma.PrismaPromise<GetGigAggregateType<T>>

    /**
     * Group by Gig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GigGroupByArgs['orderBy'] }
        : { orderBy?: GigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gig model
   */
  readonly fields: GigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    freelancer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviews<T extends Gig$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Gig$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Gig$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Gig$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gig model
   */ 
  interface GigFieldRefs {
    readonly id: FieldRef<"Gig", 'String'>
    readonly freelancerId: FieldRef<"Gig", 'String'>
    readonly title: FieldRef<"Gig", 'String'>
    readonly description: FieldRef<"Gig", 'String'>
    readonly price: FieldRef<"Gig", 'Float'>
    readonly deliveryTime: FieldRef<"Gig", 'Int'>
    readonly revisions: FieldRef<"Gig", 'Int'>
    readonly category: FieldRef<"Gig", 'String'>
    readonly subcategory: FieldRef<"Gig", 'String'>
    readonly tags: FieldRef<"Gig", 'String[]'>
    readonly images: FieldRef<"Gig", 'String[]'>
    readonly requirements: FieldRef<"Gig", 'String[]'>
    readonly status: FieldRef<"Gig", 'GigStatus'>
    readonly rating: FieldRef<"Gig", 'Float'>
    readonly createdAt: FieldRef<"Gig", 'DateTime'>
    readonly updatedAt: FieldRef<"Gig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gig findUnique
   */
  export type GigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter, which Gig to fetch.
     */
    where: GigWhereUniqueInput
  }

  /**
   * Gig findUniqueOrThrow
   */
  export type GigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter, which Gig to fetch.
     */
    where: GigWhereUniqueInput
  }

  /**
   * Gig findFirst
   */
  export type GigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter, which Gig to fetch.
     */
    where?: GigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gigs to fetch.
     */
    orderBy?: GigOrderByWithRelationInput | GigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gigs.
     */
    cursor?: GigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gigs.
     */
    distinct?: GigScalarFieldEnum | GigScalarFieldEnum[]
  }

  /**
   * Gig findFirstOrThrow
   */
  export type GigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter, which Gig to fetch.
     */
    where?: GigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gigs to fetch.
     */
    orderBy?: GigOrderByWithRelationInput | GigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gigs.
     */
    cursor?: GigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gigs.
     */
    distinct?: GigScalarFieldEnum | GigScalarFieldEnum[]
  }

  /**
   * Gig findMany
   */
  export type GigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter, which Gigs to fetch.
     */
    where?: GigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gigs to fetch.
     */
    orderBy?: GigOrderByWithRelationInput | GigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gigs.
     */
    cursor?: GigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gigs.
     */
    skip?: number
    distinct?: GigScalarFieldEnum | GigScalarFieldEnum[]
  }

  /**
   * Gig create
   */
  export type GigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * The data needed to create a Gig.
     */
    data: XOR<GigCreateInput, GigUncheckedCreateInput>
  }

  /**
   * Gig createMany
   */
  export type GigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gigs.
     */
    data: GigCreateManyInput | GigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gig createManyAndReturn
   */
  export type GigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gigs.
     */
    data: GigCreateManyInput | GigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gig update
   */
  export type GigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * The data needed to update a Gig.
     */
    data: XOR<GigUpdateInput, GigUncheckedUpdateInput>
    /**
     * Choose, which Gig to update.
     */
    where: GigWhereUniqueInput
  }

  /**
   * Gig updateMany
   */
  export type GigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gigs.
     */
    data: XOR<GigUpdateManyMutationInput, GigUncheckedUpdateManyInput>
    /**
     * Filter which Gigs to update
     */
    where?: GigWhereInput
  }

  /**
   * Gig upsert
   */
  export type GigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * The filter to search for the Gig to update in case it exists.
     */
    where: GigWhereUniqueInput
    /**
     * In case the Gig found by the `where` argument doesn't exist, create a new Gig with this data.
     */
    create: XOR<GigCreateInput, GigUncheckedCreateInput>
    /**
     * In case the Gig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GigUpdateInput, GigUncheckedUpdateInput>
  }

  /**
   * Gig delete
   */
  export type GigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
    /**
     * Filter which Gig to delete.
     */
    where: GigWhereUniqueInput
  }

  /**
   * Gig deleteMany
   */
  export type GigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gigs to delete
     */
    where?: GigWhereInput
  }

  /**
   * Gig.reviews
   */
  export type Gig$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    where?: GigReviewWhereInput
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    cursor?: GigReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GigReviewScalarFieldEnum | GigReviewScalarFieldEnum[]
  }

  /**
   * Gig.orders
   */
  export type Gig$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    where?: GigOrderWhereInput
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    cursor?: GigOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GigOrderScalarFieldEnum | GigOrderScalarFieldEnum[]
  }

  /**
   * Gig without action
   */
  export type GigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gig
     */
    select?: GigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigInclude<ExtArgs> | null
  }


  /**
   * Model GigOrder
   */

  export type AggregateGigOrder = {
    _count: GigOrderCountAggregateOutputType | null
    _avg: GigOrderAvgAggregateOutputType | null
    _sum: GigOrderSumAggregateOutputType | null
    _min: GigOrderMinAggregateOutputType | null
    _max: GigOrderMaxAggregateOutputType | null
  }

  export type GigOrderAvgAggregateOutputType = {
    deliveryTime: number | null
    revisions: number | null
  }

  export type GigOrderSumAggregateOutputType = {
    deliveryTime: number | null
    revisions: number | null
  }

  export type GigOrderMinAggregateOutputType = {
    id: string | null
    gigId: string | null
    clientId: string | null
    requirements: string | null
    deliveryTime: number | null
    revisions: number | null
    status: $Enums.GigOrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigOrderMaxAggregateOutputType = {
    id: string | null
    gigId: string | null
    clientId: string | null
    requirements: string | null
    deliveryTime: number | null
    revisions: number | null
    status: $Enums.GigOrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigOrderCountAggregateOutputType = {
    id: number
    gigId: number
    clientId: number
    requirements: number
    deliveryTime: number
    revisions: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GigOrderAvgAggregateInputType = {
    deliveryTime?: true
    revisions?: true
  }

  export type GigOrderSumAggregateInputType = {
    deliveryTime?: true
    revisions?: true
  }

  export type GigOrderMinAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    requirements?: true
    deliveryTime?: true
    revisions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigOrderMaxAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    requirements?: true
    deliveryTime?: true
    revisions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigOrderCountAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    requirements?: true
    deliveryTime?: true
    revisions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GigOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GigOrder to aggregate.
     */
    where?: GigOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigOrders to fetch.
     */
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GigOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GigOrders
    **/
    _count?: true | GigOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GigOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GigOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GigOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GigOrderMaxAggregateInputType
  }

  export type GetGigOrderAggregateType<T extends GigOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateGigOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGigOrder[P]>
      : GetScalarType<T[P], AggregateGigOrder[P]>
  }




  export type GigOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigOrderWhereInput
    orderBy?: GigOrderOrderByWithAggregationInput | GigOrderOrderByWithAggregationInput[]
    by: GigOrderScalarFieldEnum[] | GigOrderScalarFieldEnum
    having?: GigOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GigOrderCountAggregateInputType | true
    _avg?: GigOrderAvgAggregateInputType
    _sum?: GigOrderSumAggregateInputType
    _min?: GigOrderMinAggregateInputType
    _max?: GigOrderMaxAggregateInputType
  }

  export type GigOrderGroupByOutputType = {
    id: string
    gigId: string
    clientId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status: $Enums.GigOrderStatus
    createdAt: Date
    updatedAt: Date
    _count: GigOrderCountAggregateOutputType | null
    _avg: GigOrderAvgAggregateOutputType | null
    _sum: GigOrderSumAggregateOutputType | null
    _min: GigOrderMinAggregateOutputType | null
    _max: GigOrderMaxAggregateOutputType | null
  }

  type GetGigOrderGroupByPayload<T extends GigOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GigOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GigOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GigOrderGroupByOutputType[P]>
            : GetScalarType<T[P], GigOrderGroupByOutputType[P]>
        }
      >
    >


  export type GigOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    requirements?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gigOrder"]>

  export type GigOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    requirements?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gigOrder"]>

  export type GigOrderSelectScalar = {
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    requirements?: boolean
    deliveryTime?: boolean
    revisions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GigOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GigOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GigOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GigOrder"
    objects: {
      gig: Prisma.$GigPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gigId: string
      clientId: string
      requirements: string
      deliveryTime: number
      revisions: number
      status: $Enums.GigOrderStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gigOrder"]>
    composites: {}
  }

  type GigOrderGetPayload<S extends boolean | null | undefined | GigOrderDefaultArgs> = $Result.GetResult<Prisma.$GigOrderPayload, S>

  type GigOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GigOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GigOrderCountAggregateInputType | true
    }

  export interface GigOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GigOrder'], meta: { name: 'GigOrder' } }
    /**
     * Find zero or one GigOrder that matches the filter.
     * @param {GigOrderFindUniqueArgs} args - Arguments to find a GigOrder
     * @example
     * // Get one GigOrder
     * const gigOrder = await prisma.gigOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GigOrderFindUniqueArgs>(args: SelectSubset<T, GigOrderFindUniqueArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GigOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GigOrderFindUniqueOrThrowArgs} args - Arguments to find a GigOrder
     * @example
     * // Get one GigOrder
     * const gigOrder = await prisma.gigOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GigOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, GigOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GigOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderFindFirstArgs} args - Arguments to find a GigOrder
     * @example
     * // Get one GigOrder
     * const gigOrder = await prisma.gigOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GigOrderFindFirstArgs>(args?: SelectSubset<T, GigOrderFindFirstArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GigOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderFindFirstOrThrowArgs} args - Arguments to find a GigOrder
     * @example
     * // Get one GigOrder
     * const gigOrder = await prisma.gigOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GigOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, GigOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GigOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GigOrders
     * const gigOrders = await prisma.gigOrder.findMany()
     * 
     * // Get first 10 GigOrders
     * const gigOrders = await prisma.gigOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gigOrderWithIdOnly = await prisma.gigOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GigOrderFindManyArgs>(args?: SelectSubset<T, GigOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GigOrder.
     * @param {GigOrderCreateArgs} args - Arguments to create a GigOrder.
     * @example
     * // Create one GigOrder
     * const GigOrder = await prisma.gigOrder.create({
     *   data: {
     *     // ... data to create a GigOrder
     *   }
     * })
     * 
     */
    create<T extends GigOrderCreateArgs>(args: SelectSubset<T, GigOrderCreateArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GigOrders.
     * @param {GigOrderCreateManyArgs} args - Arguments to create many GigOrders.
     * @example
     * // Create many GigOrders
     * const gigOrder = await prisma.gigOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GigOrderCreateManyArgs>(args?: SelectSubset<T, GigOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GigOrders and returns the data saved in the database.
     * @param {GigOrderCreateManyAndReturnArgs} args - Arguments to create many GigOrders.
     * @example
     * // Create many GigOrders
     * const gigOrder = await prisma.gigOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GigOrders and only return the `id`
     * const gigOrderWithIdOnly = await prisma.gigOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GigOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, GigOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GigOrder.
     * @param {GigOrderDeleteArgs} args - Arguments to delete one GigOrder.
     * @example
     * // Delete one GigOrder
     * const GigOrder = await prisma.gigOrder.delete({
     *   where: {
     *     // ... filter to delete one GigOrder
     *   }
     * })
     * 
     */
    delete<T extends GigOrderDeleteArgs>(args: SelectSubset<T, GigOrderDeleteArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GigOrder.
     * @param {GigOrderUpdateArgs} args - Arguments to update one GigOrder.
     * @example
     * // Update one GigOrder
     * const gigOrder = await prisma.gigOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GigOrderUpdateArgs>(args: SelectSubset<T, GigOrderUpdateArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GigOrders.
     * @param {GigOrderDeleteManyArgs} args - Arguments to filter GigOrders to delete.
     * @example
     * // Delete a few GigOrders
     * const { count } = await prisma.gigOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GigOrderDeleteManyArgs>(args?: SelectSubset<T, GigOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GigOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GigOrders
     * const gigOrder = await prisma.gigOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GigOrderUpdateManyArgs>(args: SelectSubset<T, GigOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GigOrder.
     * @param {GigOrderUpsertArgs} args - Arguments to update or create a GigOrder.
     * @example
     * // Update or create a GigOrder
     * const gigOrder = await prisma.gigOrder.upsert({
     *   create: {
     *     // ... data to create a GigOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GigOrder we want to update
     *   }
     * })
     */
    upsert<T extends GigOrderUpsertArgs>(args: SelectSubset<T, GigOrderUpsertArgs<ExtArgs>>): Prisma__GigOrderClient<$Result.GetResult<Prisma.$GigOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GigOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderCountArgs} args - Arguments to filter GigOrders to count.
     * @example
     * // Count the number of GigOrders
     * const count = await prisma.gigOrder.count({
     *   where: {
     *     // ... the filter for the GigOrders we want to count
     *   }
     * })
    **/
    count<T extends GigOrderCountArgs>(
      args?: Subset<T, GigOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GigOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GigOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GigOrderAggregateArgs>(args: Subset<T, GigOrderAggregateArgs>): Prisma.PrismaPromise<GetGigOrderAggregateType<T>>

    /**
     * Group by GigOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GigOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GigOrderGroupByArgs['orderBy'] }
        : { orderBy?: GigOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GigOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGigOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GigOrder model
   */
  readonly fields: GigOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GigOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GigOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gig<T extends GigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GigDefaultArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GigOrder model
   */ 
  interface GigOrderFieldRefs {
    readonly id: FieldRef<"GigOrder", 'String'>
    readonly gigId: FieldRef<"GigOrder", 'String'>
    readonly clientId: FieldRef<"GigOrder", 'String'>
    readonly requirements: FieldRef<"GigOrder", 'String'>
    readonly deliveryTime: FieldRef<"GigOrder", 'Int'>
    readonly revisions: FieldRef<"GigOrder", 'Int'>
    readonly status: FieldRef<"GigOrder", 'GigOrderStatus'>
    readonly createdAt: FieldRef<"GigOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"GigOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GigOrder findUnique
   */
  export type GigOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter, which GigOrder to fetch.
     */
    where: GigOrderWhereUniqueInput
  }

  /**
   * GigOrder findUniqueOrThrow
   */
  export type GigOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter, which GigOrder to fetch.
     */
    where: GigOrderWhereUniqueInput
  }

  /**
   * GigOrder findFirst
   */
  export type GigOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter, which GigOrder to fetch.
     */
    where?: GigOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigOrders to fetch.
     */
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GigOrders.
     */
    cursor?: GigOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GigOrders.
     */
    distinct?: GigOrderScalarFieldEnum | GigOrderScalarFieldEnum[]
  }

  /**
   * GigOrder findFirstOrThrow
   */
  export type GigOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter, which GigOrder to fetch.
     */
    where?: GigOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigOrders to fetch.
     */
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GigOrders.
     */
    cursor?: GigOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GigOrders.
     */
    distinct?: GigOrderScalarFieldEnum | GigOrderScalarFieldEnum[]
  }

  /**
   * GigOrder findMany
   */
  export type GigOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter, which GigOrders to fetch.
     */
    where?: GigOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigOrders to fetch.
     */
    orderBy?: GigOrderOrderByWithRelationInput | GigOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GigOrders.
     */
    cursor?: GigOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigOrders.
     */
    skip?: number
    distinct?: GigOrderScalarFieldEnum | GigOrderScalarFieldEnum[]
  }

  /**
   * GigOrder create
   */
  export type GigOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a GigOrder.
     */
    data: XOR<GigOrderCreateInput, GigOrderUncheckedCreateInput>
  }

  /**
   * GigOrder createMany
   */
  export type GigOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GigOrders.
     */
    data: GigOrderCreateManyInput | GigOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GigOrder createManyAndReturn
   */
  export type GigOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GigOrders.
     */
    data: GigOrderCreateManyInput | GigOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GigOrder update
   */
  export type GigOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a GigOrder.
     */
    data: XOR<GigOrderUpdateInput, GigOrderUncheckedUpdateInput>
    /**
     * Choose, which GigOrder to update.
     */
    where: GigOrderWhereUniqueInput
  }

  /**
   * GigOrder updateMany
   */
  export type GigOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GigOrders.
     */
    data: XOR<GigOrderUpdateManyMutationInput, GigOrderUncheckedUpdateManyInput>
    /**
     * Filter which GigOrders to update
     */
    where?: GigOrderWhereInput
  }

  /**
   * GigOrder upsert
   */
  export type GigOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the GigOrder to update in case it exists.
     */
    where: GigOrderWhereUniqueInput
    /**
     * In case the GigOrder found by the `where` argument doesn't exist, create a new GigOrder with this data.
     */
    create: XOR<GigOrderCreateInput, GigOrderUncheckedCreateInput>
    /**
     * In case the GigOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GigOrderUpdateInput, GigOrderUncheckedUpdateInput>
  }

  /**
   * GigOrder delete
   */
  export type GigOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
    /**
     * Filter which GigOrder to delete.
     */
    where: GigOrderWhereUniqueInput
  }

  /**
   * GigOrder deleteMany
   */
  export type GigOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GigOrders to delete
     */
    where?: GigOrderWhereInput
  }

  /**
   * GigOrder without action
   */
  export type GigOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigOrder
     */
    select?: GigOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigOrderInclude<ExtArgs> | null
  }


  /**
   * Model GigReview
   */

  export type AggregateGigReview = {
    _count: GigReviewCountAggregateOutputType | null
    _avg: GigReviewAvgAggregateOutputType | null
    _sum: GigReviewSumAggregateOutputType | null
    _min: GigReviewMinAggregateOutputType | null
    _max: GigReviewMaxAggregateOutputType | null
  }

  export type GigReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type GigReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type GigReviewMinAggregateOutputType = {
    id: string | null
    gigId: string | null
    clientId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigReviewMaxAggregateOutputType = {
    id: string | null
    gigId: string | null
    clientId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GigReviewCountAggregateOutputType = {
    id: number
    gigId: number
    clientId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GigReviewAvgAggregateInputType = {
    rating?: true
  }

  export type GigReviewSumAggregateInputType = {
    rating?: true
  }

  export type GigReviewMinAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigReviewMaxAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GigReviewCountAggregateInputType = {
    id?: true
    gigId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GigReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GigReview to aggregate.
     */
    where?: GigReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigReviews to fetch.
     */
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GigReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GigReviews
    **/
    _count?: true | GigReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GigReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GigReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GigReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GigReviewMaxAggregateInputType
  }

  export type GetGigReviewAggregateType<T extends GigReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateGigReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGigReview[P]>
      : GetScalarType<T[P], AggregateGigReview[P]>
  }




  export type GigReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GigReviewWhereInput
    orderBy?: GigReviewOrderByWithAggregationInput | GigReviewOrderByWithAggregationInput[]
    by: GigReviewScalarFieldEnum[] | GigReviewScalarFieldEnum
    having?: GigReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GigReviewCountAggregateInputType | true
    _avg?: GigReviewAvgAggregateInputType
    _sum?: GigReviewSumAggregateInputType
    _min?: GigReviewMinAggregateInputType
    _max?: GigReviewMaxAggregateInputType
  }

  export type GigReviewGroupByOutputType = {
    id: string
    gigId: string
    clientId: string
    rating: number
    comment: string
    createdAt: Date
    updatedAt: Date
    _count: GigReviewCountAggregateOutputType | null
    _avg: GigReviewAvgAggregateOutputType | null
    _sum: GigReviewSumAggregateOutputType | null
    _min: GigReviewMinAggregateOutputType | null
    _max: GigReviewMaxAggregateOutputType | null
  }

  type GetGigReviewGroupByPayload<T extends GigReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GigReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GigReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GigReviewGroupByOutputType[P]>
            : GetScalarType<T[P], GigReviewGroupByOutputType[P]>
        }
      >
    >


  export type GigReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gigReview"]>

  export type GigReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gigReview"]>

  export type GigReviewSelectScalar = {
    id?: boolean
    gigId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GigReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GigReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gig?: boolean | GigDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GigReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GigReview"
    objects: {
      gig: Prisma.$GigPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gigId: string
      clientId: string
      rating: number
      comment: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gigReview"]>
    composites: {}
  }

  type GigReviewGetPayload<S extends boolean | null | undefined | GigReviewDefaultArgs> = $Result.GetResult<Prisma.$GigReviewPayload, S>

  type GigReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GigReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GigReviewCountAggregateInputType | true
    }

  export interface GigReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GigReview'], meta: { name: 'GigReview' } }
    /**
     * Find zero or one GigReview that matches the filter.
     * @param {GigReviewFindUniqueArgs} args - Arguments to find a GigReview
     * @example
     * // Get one GigReview
     * const gigReview = await prisma.gigReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GigReviewFindUniqueArgs>(args: SelectSubset<T, GigReviewFindUniqueArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GigReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GigReviewFindUniqueOrThrowArgs} args - Arguments to find a GigReview
     * @example
     * // Get one GigReview
     * const gigReview = await prisma.gigReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GigReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, GigReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GigReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewFindFirstArgs} args - Arguments to find a GigReview
     * @example
     * // Get one GigReview
     * const gigReview = await prisma.gigReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GigReviewFindFirstArgs>(args?: SelectSubset<T, GigReviewFindFirstArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GigReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewFindFirstOrThrowArgs} args - Arguments to find a GigReview
     * @example
     * // Get one GigReview
     * const gigReview = await prisma.gigReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GigReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, GigReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GigReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GigReviews
     * const gigReviews = await prisma.gigReview.findMany()
     * 
     * // Get first 10 GigReviews
     * const gigReviews = await prisma.gigReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gigReviewWithIdOnly = await prisma.gigReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GigReviewFindManyArgs>(args?: SelectSubset<T, GigReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GigReview.
     * @param {GigReviewCreateArgs} args - Arguments to create a GigReview.
     * @example
     * // Create one GigReview
     * const GigReview = await prisma.gigReview.create({
     *   data: {
     *     // ... data to create a GigReview
     *   }
     * })
     * 
     */
    create<T extends GigReviewCreateArgs>(args: SelectSubset<T, GigReviewCreateArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GigReviews.
     * @param {GigReviewCreateManyArgs} args - Arguments to create many GigReviews.
     * @example
     * // Create many GigReviews
     * const gigReview = await prisma.gigReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GigReviewCreateManyArgs>(args?: SelectSubset<T, GigReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GigReviews and returns the data saved in the database.
     * @param {GigReviewCreateManyAndReturnArgs} args - Arguments to create many GigReviews.
     * @example
     * // Create many GigReviews
     * const gigReview = await prisma.gigReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GigReviews and only return the `id`
     * const gigReviewWithIdOnly = await prisma.gigReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GigReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, GigReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GigReview.
     * @param {GigReviewDeleteArgs} args - Arguments to delete one GigReview.
     * @example
     * // Delete one GigReview
     * const GigReview = await prisma.gigReview.delete({
     *   where: {
     *     // ... filter to delete one GigReview
     *   }
     * })
     * 
     */
    delete<T extends GigReviewDeleteArgs>(args: SelectSubset<T, GigReviewDeleteArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GigReview.
     * @param {GigReviewUpdateArgs} args - Arguments to update one GigReview.
     * @example
     * // Update one GigReview
     * const gigReview = await prisma.gigReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GigReviewUpdateArgs>(args: SelectSubset<T, GigReviewUpdateArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GigReviews.
     * @param {GigReviewDeleteManyArgs} args - Arguments to filter GigReviews to delete.
     * @example
     * // Delete a few GigReviews
     * const { count } = await prisma.gigReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GigReviewDeleteManyArgs>(args?: SelectSubset<T, GigReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GigReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GigReviews
     * const gigReview = await prisma.gigReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GigReviewUpdateManyArgs>(args: SelectSubset<T, GigReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GigReview.
     * @param {GigReviewUpsertArgs} args - Arguments to update or create a GigReview.
     * @example
     * // Update or create a GigReview
     * const gigReview = await prisma.gigReview.upsert({
     *   create: {
     *     // ... data to create a GigReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GigReview we want to update
     *   }
     * })
     */
    upsert<T extends GigReviewUpsertArgs>(args: SelectSubset<T, GigReviewUpsertArgs<ExtArgs>>): Prisma__GigReviewClient<$Result.GetResult<Prisma.$GigReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GigReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewCountArgs} args - Arguments to filter GigReviews to count.
     * @example
     * // Count the number of GigReviews
     * const count = await prisma.gigReview.count({
     *   where: {
     *     // ... the filter for the GigReviews we want to count
     *   }
     * })
    **/
    count<T extends GigReviewCountArgs>(
      args?: Subset<T, GigReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GigReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GigReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GigReviewAggregateArgs>(args: Subset<T, GigReviewAggregateArgs>): Prisma.PrismaPromise<GetGigReviewAggregateType<T>>

    /**
     * Group by GigReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GigReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GigReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GigReviewGroupByArgs['orderBy'] }
        : { orderBy?: GigReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GigReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGigReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GigReview model
   */
  readonly fields: GigReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GigReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GigReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gig<T extends GigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GigDefaultArgs<ExtArgs>>): Prisma__GigClient<$Result.GetResult<Prisma.$GigPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GigReview model
   */ 
  interface GigReviewFieldRefs {
    readonly id: FieldRef<"GigReview", 'String'>
    readonly gigId: FieldRef<"GigReview", 'String'>
    readonly clientId: FieldRef<"GigReview", 'String'>
    readonly rating: FieldRef<"GigReview", 'Int'>
    readonly comment: FieldRef<"GigReview", 'String'>
    readonly createdAt: FieldRef<"GigReview", 'DateTime'>
    readonly updatedAt: FieldRef<"GigReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GigReview findUnique
   */
  export type GigReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter, which GigReview to fetch.
     */
    where: GigReviewWhereUniqueInput
  }

  /**
   * GigReview findUniqueOrThrow
   */
  export type GigReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter, which GigReview to fetch.
     */
    where: GigReviewWhereUniqueInput
  }

  /**
   * GigReview findFirst
   */
  export type GigReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter, which GigReview to fetch.
     */
    where?: GigReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigReviews to fetch.
     */
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GigReviews.
     */
    cursor?: GigReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GigReviews.
     */
    distinct?: GigReviewScalarFieldEnum | GigReviewScalarFieldEnum[]
  }

  /**
   * GigReview findFirstOrThrow
   */
  export type GigReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter, which GigReview to fetch.
     */
    where?: GigReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigReviews to fetch.
     */
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GigReviews.
     */
    cursor?: GigReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GigReviews.
     */
    distinct?: GigReviewScalarFieldEnum | GigReviewScalarFieldEnum[]
  }

  /**
   * GigReview findMany
   */
  export type GigReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter, which GigReviews to fetch.
     */
    where?: GigReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GigReviews to fetch.
     */
    orderBy?: GigReviewOrderByWithRelationInput | GigReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GigReviews.
     */
    cursor?: GigReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GigReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GigReviews.
     */
    skip?: number
    distinct?: GigReviewScalarFieldEnum | GigReviewScalarFieldEnum[]
  }

  /**
   * GigReview create
   */
  export type GigReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a GigReview.
     */
    data: XOR<GigReviewCreateInput, GigReviewUncheckedCreateInput>
  }

  /**
   * GigReview createMany
   */
  export type GigReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GigReviews.
     */
    data: GigReviewCreateManyInput | GigReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GigReview createManyAndReturn
   */
  export type GigReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GigReviews.
     */
    data: GigReviewCreateManyInput | GigReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GigReview update
   */
  export type GigReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a GigReview.
     */
    data: XOR<GigReviewUpdateInput, GigReviewUncheckedUpdateInput>
    /**
     * Choose, which GigReview to update.
     */
    where: GigReviewWhereUniqueInput
  }

  /**
   * GigReview updateMany
   */
  export type GigReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GigReviews.
     */
    data: XOR<GigReviewUpdateManyMutationInput, GigReviewUncheckedUpdateManyInput>
    /**
     * Filter which GigReviews to update
     */
    where?: GigReviewWhereInput
  }

  /**
   * GigReview upsert
   */
  export type GigReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the GigReview to update in case it exists.
     */
    where: GigReviewWhereUniqueInput
    /**
     * In case the GigReview found by the `where` argument doesn't exist, create a new GigReview with this data.
     */
    create: XOR<GigReviewCreateInput, GigReviewUncheckedCreateInput>
    /**
     * In case the GigReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GigReviewUpdateInput, GigReviewUncheckedUpdateInput>
  }

  /**
   * GigReview delete
   */
  export type GigReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
    /**
     * Filter which GigReview to delete.
     */
    where: GigReviewWhereUniqueInput
  }

  /**
   * GigReview deleteMany
   */
  export type GigReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GigReviews to delete
     */
    where?: GigReviewWhereInput
  }

  /**
   * GigReview without action
   */
  export type GigReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GigReview
     */
    select?: GigReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GigReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FreelancerProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    experience: 'experience',
    education: 'education',
    location: 'location',
    languages: 'languages',
    portfolio: 'portfolio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelancerProfileScalarFieldEnum = (typeof FreelancerProfileScalarFieldEnum)[keyof typeof FreelancerProfileScalarFieldEnum]


  export const ClientProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    website: 'website',
    description: 'description',
    industry: 'industry',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientProfileScalarFieldEnum = (typeof ClientProfileScalarFieldEnum)[keyof typeof ClientProfileScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const FreelancerSkillScalarFieldEnum: {
    id: 'id',
    freelancerId: 'freelancerId',
    skillId: 'skillId',
    yearsExperience: 'yearsExperience',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelancerSkillScalarFieldEnum = (typeof FreelancerSkillScalarFieldEnum)[keyof typeof FreelancerSkillScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    title: 'title',
    description: 'description',
    budget: 'budget',
    deadline: 'deadline',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectSkillScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    skillId: 'skillId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectSkillScalarFieldEnum = (typeof ProjectSkillScalarFieldEnum)[keyof typeof ProjectSkillScalarFieldEnum]


  export const BidScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    freelancerId: 'freelancerId',
    amount: 'amount',
    duration: 'duration',
    coverLetter: 'coverLetter',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidScalarFieldEnum = (typeof BidScalarFieldEnum)[keyof typeof BidScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    bidId: 'bidId',
    clientId: 'clientId',
    freelancerId: 'freelancerId',
    terms: 'terms',
    amount: 'amount',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    amount: 'amount',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    projectId: 'projectId',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AdminActionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    userId: 'userId',
    projectId: 'projectId',
    action: 'action',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminActionScalarFieldEnum = (typeof AdminActionScalarFieldEnum)[keyof typeof AdminActionScalarFieldEnum]


  export const GigScalarFieldEnum: {
    id: 'id',
    freelancerId: 'freelancerId',
    title: 'title',
    description: 'description',
    price: 'price',
    deliveryTime: 'deliveryTime',
    revisions: 'revisions',
    category: 'category',
    subcategory: 'subcategory',
    tags: 'tags',
    images: 'images',
    requirements: 'requirements',
    status: 'status',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GigScalarFieldEnum = (typeof GigScalarFieldEnum)[keyof typeof GigScalarFieldEnum]


  export const GigOrderScalarFieldEnum: {
    id: 'id',
    gigId: 'gigId',
    clientId: 'clientId',
    requirements: 'requirements',
    deliveryTime: 'deliveryTime',
    revisions: 'revisions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GigOrderScalarFieldEnum = (typeof GigOrderScalarFieldEnum)[keyof typeof GigOrderScalarFieldEnum]


  export const GigReviewScalarFieldEnum: {
    id: 'id',
    gigId: 'gigId',
    clientId: 'clientId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GigReviewScalarFieldEnum = (typeof GigReviewScalarFieldEnum)[keyof typeof GigReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'BidStatus'
   */
  export type EnumBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidStatus'>
    


  /**
   * Reference to a field of type 'BidStatus[]'
   */
  export type ListEnumBidStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BidStatus[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'AdminActionType'
   */
  export type EnumAdminActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminActionType'>
    


  /**
   * Reference to a field of type 'AdminActionType[]'
   */
  export type ListEnumAdminActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminActionType[]'>
    


  /**
   * Reference to a field of type 'GigStatus'
   */
  export type EnumGigStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GigStatus'>
    


  /**
   * Reference to a field of type 'GigStatus[]'
   */
  export type ListEnumGigStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GigStatus[]'>
    


  /**
   * Reference to a field of type 'GigOrderStatus'
   */
  export type EnumGigOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GigOrderStatus'>
    


  /**
   * Reference to a field of type 'GigOrderStatus[]'
   */
  export type ListEnumGigOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GigOrderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    freelancerProfile?: XOR<FreelancerProfileNullableRelationFilter, FreelancerProfileWhereInput> | null
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    postedProjects?: ProjectListRelationFilter
    bids?: BidListRelationFilter
    clientContracts?: ContractListRelationFilter
    freelancerContracts?: ContractListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    givenReviews?: ReviewListRelationFilter
    receivedReviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    adminActions?: AdminActionListRelationFilter
    performedActions?: AdminActionListRelationFilter
    gigs?: GigListRelationFilter
    gigOrders?: GigOrderListRelationFilter
    gigReviews?: GigReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelancerProfile?: FreelancerProfileOrderByWithRelationInput
    clientProfile?: ClientProfileOrderByWithRelationInput
    postedProjects?: ProjectOrderByRelationAggregateInput
    bids?: BidOrderByRelationAggregateInput
    clientContracts?: ContractOrderByRelationAggregateInput
    freelancerContracts?: ContractOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    givenReviews?: ReviewOrderByRelationAggregateInput
    receivedReviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    adminActions?: AdminActionOrderByRelationAggregateInput
    performedActions?: AdminActionOrderByRelationAggregateInput
    gigs?: GigOrderByRelationAggregateInput
    gigOrders?: GigOrderOrderByRelationAggregateInput
    gigReviews?: GigReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    freelancerProfile?: XOR<FreelancerProfileNullableRelationFilter, FreelancerProfileWhereInput> | null
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
    postedProjects?: ProjectListRelationFilter
    bids?: BidListRelationFilter
    clientContracts?: ContractListRelationFilter
    freelancerContracts?: ContractListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    givenReviews?: ReviewListRelationFilter
    receivedReviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    adminActions?: AdminActionListRelationFilter
    performedActions?: AdminActionListRelationFilter
    gigs?: GigListRelationFilter
    gigOrders?: GigOrderListRelationFilter
    gigReviews?: GigReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type FreelancerProfileWhereInput = {
    AND?: FreelancerProfileWhereInput | FreelancerProfileWhereInput[]
    OR?: FreelancerProfileWhereInput[]
    NOT?: FreelancerProfileWhereInput | FreelancerProfileWhereInput[]
    id?: StringFilter<"FreelancerProfile"> | string
    userId?: StringFilter<"FreelancerProfile"> | string
    title?: StringFilter<"FreelancerProfile"> | string
    description?: StringFilter<"FreelancerProfile"> | string
    experience?: IntFilter<"FreelancerProfile"> | number
    education?: StringNullableFilter<"FreelancerProfile"> | string | null
    location?: StringFilter<"FreelancerProfile"> | string
    languages?: StringNullableListFilter<"FreelancerProfile">
    portfolio?: JsonNullableFilter<"FreelancerProfile">
    createdAt?: DateTimeFilter<"FreelancerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FreelancerProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: FreelancerSkillListRelationFilter
  }

  export type FreelancerProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    education?: SortOrderInput | SortOrder
    location?: SortOrder
    languages?: SortOrder
    portfolio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    skills?: FreelancerSkillOrderByRelationAggregateInput
  }

  export type FreelancerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FreelancerProfileWhereInput | FreelancerProfileWhereInput[]
    OR?: FreelancerProfileWhereInput[]
    NOT?: FreelancerProfileWhereInput | FreelancerProfileWhereInput[]
    title?: StringFilter<"FreelancerProfile"> | string
    description?: StringFilter<"FreelancerProfile"> | string
    experience?: IntFilter<"FreelancerProfile"> | number
    education?: StringNullableFilter<"FreelancerProfile"> | string | null
    location?: StringFilter<"FreelancerProfile"> | string
    languages?: StringNullableListFilter<"FreelancerProfile">
    portfolio?: JsonNullableFilter<"FreelancerProfile">
    createdAt?: DateTimeFilter<"FreelancerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FreelancerProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    skills?: FreelancerSkillListRelationFilter
  }, "id" | "userId">

  export type FreelancerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    education?: SortOrderInput | SortOrder
    location?: SortOrder
    languages?: SortOrder
    portfolio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelancerProfileCountOrderByAggregateInput
    _avg?: FreelancerProfileAvgOrderByAggregateInput
    _max?: FreelancerProfileMaxOrderByAggregateInput
    _min?: FreelancerProfileMinOrderByAggregateInput
    _sum?: FreelancerProfileSumOrderByAggregateInput
  }

  export type FreelancerProfileScalarWhereWithAggregatesInput = {
    AND?: FreelancerProfileScalarWhereWithAggregatesInput | FreelancerProfileScalarWhereWithAggregatesInput[]
    OR?: FreelancerProfileScalarWhereWithAggregatesInput[]
    NOT?: FreelancerProfileScalarWhereWithAggregatesInput | FreelancerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FreelancerProfile"> | string
    userId?: StringWithAggregatesFilter<"FreelancerProfile"> | string
    title?: StringWithAggregatesFilter<"FreelancerProfile"> | string
    description?: StringWithAggregatesFilter<"FreelancerProfile"> | string
    experience?: IntWithAggregatesFilter<"FreelancerProfile"> | number
    education?: StringNullableWithAggregatesFilter<"FreelancerProfile"> | string | null
    location?: StringWithAggregatesFilter<"FreelancerProfile"> | string
    languages?: StringNullableListFilter<"FreelancerProfile">
    portfolio?: JsonNullableWithAggregatesFilter<"FreelancerProfile">
    createdAt?: DateTimeWithAggregatesFilter<"FreelancerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelancerProfile"> | Date | string
  }

  export type ClientProfileWhereInput = {
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    userId?: StringFilter<"ClientProfile"> | string
    companyName?: StringNullableFilter<"ClientProfile"> | string | null
    website?: StringNullableFilter<"ClientProfile"> | string | null
    description?: StringNullableFilter<"ClientProfile"> | string | null
    industry?: StringNullableFilter<"ClientProfile"> | string | null
    location?: StringFilter<"ClientProfile"> | string
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    companyName?: StringNullableFilter<"ClientProfile"> | string | null
    website?: StringNullableFilter<"ClientProfile"> | string | null
    description?: StringNullableFilter<"ClientProfile"> | string | null
    industry?: StringNullableFilter<"ClientProfile"> | string | null
    location?: StringFilter<"ClientProfile"> | string
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientProfileCountOrderByAggregateInput
    _max?: ClientProfileMaxOrderByAggregateInput
    _min?: ClientProfileMinOrderByAggregateInput
  }

  export type ClientProfileScalarWhereWithAggregatesInput = {
    AND?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    OR?: ClientProfileScalarWhereWithAggregatesInput[]
    NOT?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientProfile"> | string
    userId?: StringWithAggregatesFilter<"ClientProfile"> | string
    companyName?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    description?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    industry?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    location?: StringWithAggregatesFilter<"ClientProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    category?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    freelancers?: FreelancerSkillListRelationFilter
    projects?: ProjectSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelancers?: FreelancerSkillOrderByRelationAggregateInput
    projects?: ProjectSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    category?: StringFilter<"Skill"> | string
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    freelancers?: FreelancerSkillListRelationFilter
    projects?: ProjectSkillListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    category?: StringWithAggregatesFilter<"Skill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type FreelancerSkillWhereInput = {
    AND?: FreelancerSkillWhereInput | FreelancerSkillWhereInput[]
    OR?: FreelancerSkillWhereInput[]
    NOT?: FreelancerSkillWhereInput | FreelancerSkillWhereInput[]
    id?: StringFilter<"FreelancerSkill"> | string
    freelancerId?: StringFilter<"FreelancerSkill"> | string
    skillId?: StringFilter<"FreelancerSkill"> | string
    yearsExperience?: IntFilter<"FreelancerSkill"> | number
    createdAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
    freelancer?: XOR<FreelancerProfileRelationFilter, FreelancerProfileWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type FreelancerSkillOrderByWithRelationInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    skillId?: SortOrder
    yearsExperience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelancer?: FreelancerProfileOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type FreelancerSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    freelancerId_skillId?: FreelancerSkillFreelancerIdSkillIdCompoundUniqueInput
    AND?: FreelancerSkillWhereInput | FreelancerSkillWhereInput[]
    OR?: FreelancerSkillWhereInput[]
    NOT?: FreelancerSkillWhereInput | FreelancerSkillWhereInput[]
    freelancerId?: StringFilter<"FreelancerSkill"> | string
    skillId?: StringFilter<"FreelancerSkill"> | string
    yearsExperience?: IntFilter<"FreelancerSkill"> | number
    createdAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
    freelancer?: XOR<FreelancerProfileRelationFilter, FreelancerProfileWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "freelancerId_skillId">

  export type FreelancerSkillOrderByWithAggregationInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    skillId?: SortOrder
    yearsExperience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelancerSkillCountOrderByAggregateInput
    _avg?: FreelancerSkillAvgOrderByAggregateInput
    _max?: FreelancerSkillMaxOrderByAggregateInput
    _min?: FreelancerSkillMinOrderByAggregateInput
    _sum?: FreelancerSkillSumOrderByAggregateInput
  }

  export type FreelancerSkillScalarWhereWithAggregatesInput = {
    AND?: FreelancerSkillScalarWhereWithAggregatesInput | FreelancerSkillScalarWhereWithAggregatesInput[]
    OR?: FreelancerSkillScalarWhereWithAggregatesInput[]
    NOT?: FreelancerSkillScalarWhereWithAggregatesInput | FreelancerSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FreelancerSkill"> | string
    freelancerId?: StringWithAggregatesFilter<"FreelancerSkill"> | string
    skillId?: StringWithAggregatesFilter<"FreelancerSkill"> | string
    yearsExperience?: IntWithAggregatesFilter<"FreelancerSkill"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FreelancerSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelancerSkill"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    budget?: FloatFilter<"Project"> | number
    deadline?: DateTimeFilter<"Project"> | Date | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<UserRelationFilter, UserWhereInput>
    skills?: ProjectSkillListRelationFilter
    bids?: BidListRelationFilter
    messages?: MessageListRelationFilter
    contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
    adminActions?: AdminActionListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: UserOrderByWithRelationInput
    skills?: ProjectSkillOrderByRelationAggregateInput
    bids?: BidOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    contract?: ContractOrderByWithRelationInput
    adminActions?: AdminActionOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    clientId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    budget?: FloatFilter<"Project"> | number
    deadline?: DateTimeFilter<"Project"> | Date | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<UserRelationFilter, UserWhereInput>
    skills?: ProjectSkillListRelationFilter
    bids?: BidListRelationFilter
    messages?: MessageListRelationFilter
    contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
    adminActions?: AdminActionListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    clientId?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    budget?: FloatWithAggregatesFilter<"Project"> | number
    deadline?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectSkillWhereInput = {
    AND?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    OR?: ProjectSkillWhereInput[]
    NOT?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    id?: StringFilter<"ProjectSkill"> | string
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
    createdAt?: DateTimeFilter<"ProjectSkill"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSkill"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type ProjectSkillOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type ProjectSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_skillId?: ProjectSkillProjectIdSkillIdCompoundUniqueInput
    AND?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    OR?: ProjectSkillWhereInput[]
    NOT?: ProjectSkillWhereInput | ProjectSkillWhereInput[]
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
    createdAt?: DateTimeFilter<"ProjectSkill"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSkill"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "projectId_skillId">

  export type ProjectSkillOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectSkillCountOrderByAggregateInput
    _max?: ProjectSkillMaxOrderByAggregateInput
    _min?: ProjectSkillMinOrderByAggregateInput
  }

  export type ProjectSkillScalarWhereWithAggregatesInput = {
    AND?: ProjectSkillScalarWhereWithAggregatesInput | ProjectSkillScalarWhereWithAggregatesInput[]
    OR?: ProjectSkillScalarWhereWithAggregatesInput[]
    NOT?: ProjectSkillScalarWhereWithAggregatesInput | ProjectSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectSkill"> | string
    projectId?: StringWithAggregatesFilter<"ProjectSkill"> | string
    skillId?: StringWithAggregatesFilter<"ProjectSkill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectSkill"> | Date | string
  }

  export type BidWhereInput = {
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    id?: StringFilter<"Bid"> | string
    projectId?: StringFilter<"Bid"> | string
    freelancerId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    duration?: IntFilter<"Bid"> | number
    coverLetter?: StringFilter<"Bid"> | string
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
  }

  export type BidOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    freelancerId?: SortOrder
    amount?: SortOrder
    duration?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    freelancer?: UserOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
  }

  export type BidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_freelancerId?: BidProjectIdFreelancerIdCompoundUniqueInput
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    projectId?: StringFilter<"Bid"> | string
    freelancerId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    duration?: IntFilter<"Bid"> | number
    coverLetter?: StringFilter<"Bid"> | string
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    contract?: XOR<ContractNullableRelationFilter, ContractWhereInput> | null
  }, "id" | "projectId_freelancerId">

  export type BidOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    freelancerId?: SortOrder
    amount?: SortOrder
    duration?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidCountOrderByAggregateInput
    _avg?: BidAvgOrderByAggregateInput
    _max?: BidMaxOrderByAggregateInput
    _min?: BidMinOrderByAggregateInput
    _sum?: BidSumOrderByAggregateInput
  }

  export type BidScalarWhereWithAggregatesInput = {
    AND?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    OR?: BidScalarWhereWithAggregatesInput[]
    NOT?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bid"> | string
    projectId?: StringWithAggregatesFilter<"Bid"> | string
    freelancerId?: StringWithAggregatesFilter<"Bid"> | string
    amount?: FloatWithAggregatesFilter<"Bid"> | number
    duration?: IntWithAggregatesFilter<"Bid"> | number
    coverLetter?: StringWithAggregatesFilter<"Bid"> | string
    status?: EnumBidStatusWithAggregatesFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    projectId?: StringFilter<"Contract"> | string
    bidId?: StringFilter<"Contract"> | string
    clientId?: StringFilter<"Contract"> | string
    freelancerId?: StringFilter<"Contract"> | string
    terms?: StringFilter<"Contract"> | string
    amount?: FloatFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    bid?: XOR<BidRelationFilter, BidWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    bidId?: SortOrder
    clientId?: SortOrder
    freelancerId?: SortOrder
    terms?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    bid?: BidOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    freelancer?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    bidId?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    clientId?: StringFilter<"Contract"> | string
    freelancerId?: StringFilter<"Contract"> | string
    terms?: StringFilter<"Contract"> | string
    amount?: FloatFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    bid?: XOR<BidRelationFilter, BidWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "projectId" | "bidId">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    bidId?: SortOrder
    clientId?: SortOrder
    freelancerId?: SortOrder
    terms?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    projectId?: StringWithAggregatesFilter<"Contract"> | string
    bidId?: StringWithAggregatesFilter<"Contract"> | string
    clientId?: StringWithAggregatesFilter<"Contract"> | string
    freelancerId?: StringWithAggregatesFilter<"Contract"> | string
    terms?: StringWithAggregatesFilter<"Contract"> | string
    amount?: FloatWithAggregatesFilter<"Contract"> | number
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusWithAggregatesFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    contractId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    contractId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    contractId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    description?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    projectId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    projectId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    projectId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    contractId?: StringFilter<"Review"> | string
    fromUserId?: StringFilter<"Review"> | string
    toUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId_fromUserId_toUserId?: ReviewContractIdFromUserIdToUserIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    contractId?: StringFilter<"Review"> | string
    fromUserId?: StringFilter<"Review"> | string
    toUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "contractId_fromUserId_toUserId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    contractId?: StringWithAggregatesFilter<"Review"> | string
    fromUserId?: StringWithAggregatesFilter<"Review"> | string
    toUserId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AdminActionWhereInput = {
    AND?: AdminActionWhereInput | AdminActionWhereInput[]
    OR?: AdminActionWhereInput[]
    NOT?: AdminActionWhereInput | AdminActionWhereInput[]
    id?: StringFilter<"AdminAction"> | string
    adminId?: StringFilter<"AdminAction"> | string
    userId?: StringNullableFilter<"AdminAction"> | string | null
    projectId?: StringNullableFilter<"AdminAction"> | string | null
    action?: EnumAdminActionTypeFilter<"AdminAction"> | $Enums.AdminActionType
    reason?: StringFilter<"AdminAction"> | string
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAction"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }

  export type AdminActionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    action?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type AdminActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminActionWhereInput | AdminActionWhereInput[]
    OR?: AdminActionWhereInput[]
    NOT?: AdminActionWhereInput | AdminActionWhereInput[]
    adminId?: StringFilter<"AdminAction"> | string
    userId?: StringNullableFilter<"AdminAction"> | string | null
    projectId?: StringNullableFilter<"AdminAction"> | string | null
    action?: EnumAdminActionTypeFilter<"AdminAction"> | $Enums.AdminActionType
    reason?: StringFilter<"AdminAction"> | string
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAction"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type AdminActionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    action?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminActionCountOrderByAggregateInput
    _max?: AdminActionMaxOrderByAggregateInput
    _min?: AdminActionMinOrderByAggregateInput
  }

  export type AdminActionScalarWhereWithAggregatesInput = {
    AND?: AdminActionScalarWhereWithAggregatesInput | AdminActionScalarWhereWithAggregatesInput[]
    OR?: AdminActionScalarWhereWithAggregatesInput[]
    NOT?: AdminActionScalarWhereWithAggregatesInput | AdminActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAction"> | string
    adminId?: StringWithAggregatesFilter<"AdminAction"> | string
    userId?: StringNullableWithAggregatesFilter<"AdminAction"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"AdminAction"> | string | null
    action?: EnumAdminActionTypeWithAggregatesFilter<"AdminAction"> | $Enums.AdminActionType
    reason?: StringWithAggregatesFilter<"AdminAction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminAction"> | Date | string
  }

  export type GigWhereInput = {
    AND?: GigWhereInput | GigWhereInput[]
    OR?: GigWhereInput[]
    NOT?: GigWhereInput | GigWhereInput[]
    id?: StringFilter<"Gig"> | string
    freelancerId?: StringFilter<"Gig"> | string
    title?: StringFilter<"Gig"> | string
    description?: StringFilter<"Gig"> | string
    price?: FloatFilter<"Gig"> | number
    deliveryTime?: IntFilter<"Gig"> | number
    revisions?: IntFilter<"Gig"> | number
    category?: StringFilter<"Gig"> | string
    subcategory?: StringFilter<"Gig"> | string
    tags?: StringNullableListFilter<"Gig">
    images?: StringNullableListFilter<"Gig">
    requirements?: StringNullableListFilter<"Gig">
    status?: EnumGigStatusFilter<"Gig"> | $Enums.GigStatus
    rating?: FloatFilter<"Gig"> | number
    createdAt?: DateTimeFilter<"Gig"> | Date | string
    updatedAt?: DateTimeFilter<"Gig"> | Date | string
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: GigReviewListRelationFilter
    orders?: GigOrderListRelationFilter
  }

  export type GigOrderByWithRelationInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    freelancer?: UserOrderByWithRelationInput
    reviews?: GigReviewOrderByRelationAggregateInput
    orders?: GigOrderOrderByRelationAggregateInput
  }

  export type GigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GigWhereInput | GigWhereInput[]
    OR?: GigWhereInput[]
    NOT?: GigWhereInput | GigWhereInput[]
    freelancerId?: StringFilter<"Gig"> | string
    title?: StringFilter<"Gig"> | string
    description?: StringFilter<"Gig"> | string
    price?: FloatFilter<"Gig"> | number
    deliveryTime?: IntFilter<"Gig"> | number
    revisions?: IntFilter<"Gig"> | number
    category?: StringFilter<"Gig"> | string
    subcategory?: StringFilter<"Gig"> | string
    tags?: StringNullableListFilter<"Gig">
    images?: StringNullableListFilter<"Gig">
    requirements?: StringNullableListFilter<"Gig">
    status?: EnumGigStatusFilter<"Gig"> | $Enums.GigStatus
    rating?: FloatFilter<"Gig"> | number
    createdAt?: DateTimeFilter<"Gig"> | Date | string
    updatedAt?: DateTimeFilter<"Gig"> | Date | string
    freelancer?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: GigReviewListRelationFilter
    orders?: GigOrderListRelationFilter
  }, "id">

  export type GigOrderByWithAggregationInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GigCountOrderByAggregateInput
    _avg?: GigAvgOrderByAggregateInput
    _max?: GigMaxOrderByAggregateInput
    _min?: GigMinOrderByAggregateInput
    _sum?: GigSumOrderByAggregateInput
  }

  export type GigScalarWhereWithAggregatesInput = {
    AND?: GigScalarWhereWithAggregatesInput | GigScalarWhereWithAggregatesInput[]
    OR?: GigScalarWhereWithAggregatesInput[]
    NOT?: GigScalarWhereWithAggregatesInput | GigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gig"> | string
    freelancerId?: StringWithAggregatesFilter<"Gig"> | string
    title?: StringWithAggregatesFilter<"Gig"> | string
    description?: StringWithAggregatesFilter<"Gig"> | string
    price?: FloatWithAggregatesFilter<"Gig"> | number
    deliveryTime?: IntWithAggregatesFilter<"Gig"> | number
    revisions?: IntWithAggregatesFilter<"Gig"> | number
    category?: StringWithAggregatesFilter<"Gig"> | string
    subcategory?: StringWithAggregatesFilter<"Gig"> | string
    tags?: StringNullableListFilter<"Gig">
    images?: StringNullableListFilter<"Gig">
    requirements?: StringNullableListFilter<"Gig">
    status?: EnumGigStatusWithAggregatesFilter<"Gig"> | $Enums.GigStatus
    rating?: FloatWithAggregatesFilter<"Gig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Gig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gig"> | Date | string
  }

  export type GigOrderWhereInput = {
    AND?: GigOrderWhereInput | GigOrderWhereInput[]
    OR?: GigOrderWhereInput[]
    NOT?: GigOrderWhereInput | GigOrderWhereInput[]
    id?: StringFilter<"GigOrder"> | string
    gigId?: StringFilter<"GigOrder"> | string
    clientId?: StringFilter<"GigOrder"> | string
    requirements?: StringFilter<"GigOrder"> | string
    deliveryTime?: IntFilter<"GigOrder"> | number
    revisions?: IntFilter<"GigOrder"> | number
    status?: EnumGigOrderStatusFilter<"GigOrder"> | $Enums.GigOrderStatus
    createdAt?: DateTimeFilter<"GigOrder"> | Date | string
    updatedAt?: DateTimeFilter<"GigOrder"> | Date | string
    gig?: XOR<GigRelationFilter, GigWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GigOrderOrderByWithRelationInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    requirements?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gig?: GigOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
  }

  export type GigOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GigOrderWhereInput | GigOrderWhereInput[]
    OR?: GigOrderWhereInput[]
    NOT?: GigOrderWhereInput | GigOrderWhereInput[]
    gigId?: StringFilter<"GigOrder"> | string
    clientId?: StringFilter<"GigOrder"> | string
    requirements?: StringFilter<"GigOrder"> | string
    deliveryTime?: IntFilter<"GigOrder"> | number
    revisions?: IntFilter<"GigOrder"> | number
    status?: EnumGigOrderStatusFilter<"GigOrder"> | $Enums.GigOrderStatus
    createdAt?: DateTimeFilter<"GigOrder"> | Date | string
    updatedAt?: DateTimeFilter<"GigOrder"> | Date | string
    gig?: XOR<GigRelationFilter, GigWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type GigOrderOrderByWithAggregationInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    requirements?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GigOrderCountOrderByAggregateInput
    _avg?: GigOrderAvgOrderByAggregateInput
    _max?: GigOrderMaxOrderByAggregateInput
    _min?: GigOrderMinOrderByAggregateInput
    _sum?: GigOrderSumOrderByAggregateInput
  }

  export type GigOrderScalarWhereWithAggregatesInput = {
    AND?: GigOrderScalarWhereWithAggregatesInput | GigOrderScalarWhereWithAggregatesInput[]
    OR?: GigOrderScalarWhereWithAggregatesInput[]
    NOT?: GigOrderScalarWhereWithAggregatesInput | GigOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GigOrder"> | string
    gigId?: StringWithAggregatesFilter<"GigOrder"> | string
    clientId?: StringWithAggregatesFilter<"GigOrder"> | string
    requirements?: StringWithAggregatesFilter<"GigOrder"> | string
    deliveryTime?: IntWithAggregatesFilter<"GigOrder"> | number
    revisions?: IntWithAggregatesFilter<"GigOrder"> | number
    status?: EnumGigOrderStatusWithAggregatesFilter<"GigOrder"> | $Enums.GigOrderStatus
    createdAt?: DateTimeWithAggregatesFilter<"GigOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GigOrder"> | Date | string
  }

  export type GigReviewWhereInput = {
    AND?: GigReviewWhereInput | GigReviewWhereInput[]
    OR?: GigReviewWhereInput[]
    NOT?: GigReviewWhereInput | GigReviewWhereInput[]
    id?: StringFilter<"GigReview"> | string
    gigId?: StringFilter<"GigReview"> | string
    clientId?: StringFilter<"GigReview"> | string
    rating?: IntFilter<"GigReview"> | number
    comment?: StringFilter<"GigReview"> | string
    createdAt?: DateTimeFilter<"GigReview"> | Date | string
    updatedAt?: DateTimeFilter<"GigReview"> | Date | string
    gig?: XOR<GigRelationFilter, GigWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GigReviewOrderByWithRelationInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gig?: GigOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
  }

  export type GigReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gigId_clientId?: GigReviewGigIdClientIdCompoundUniqueInput
    AND?: GigReviewWhereInput | GigReviewWhereInput[]
    OR?: GigReviewWhereInput[]
    NOT?: GigReviewWhereInput | GigReviewWhereInput[]
    gigId?: StringFilter<"GigReview"> | string
    clientId?: StringFilter<"GigReview"> | string
    rating?: IntFilter<"GigReview"> | number
    comment?: StringFilter<"GigReview"> | string
    createdAt?: DateTimeFilter<"GigReview"> | Date | string
    updatedAt?: DateTimeFilter<"GigReview"> | Date | string
    gig?: XOR<GigRelationFilter, GigWhereInput>
    client?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "gigId_clientId">

  export type GigReviewOrderByWithAggregationInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GigReviewCountOrderByAggregateInput
    _avg?: GigReviewAvgOrderByAggregateInput
    _max?: GigReviewMaxOrderByAggregateInput
    _min?: GigReviewMinOrderByAggregateInput
    _sum?: GigReviewSumOrderByAggregateInput
  }

  export type GigReviewScalarWhereWithAggregatesInput = {
    AND?: GigReviewScalarWhereWithAggregatesInput | GigReviewScalarWhereWithAggregatesInput[]
    OR?: GigReviewScalarWhereWithAggregatesInput[]
    NOT?: GigReviewScalarWhereWithAggregatesInput | GigReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GigReview"> | string
    gigId?: StringWithAggregatesFilter<"GigReview"> | string
    clientId?: StringWithAggregatesFilter<"GigReview"> | string
    rating?: IntWithAggregatesFilter<"GigReview"> | number
    comment?: StringWithAggregatesFilter<"GigReview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GigReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GigReview"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerProfileCreateInput = {
    id?: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFreelancerProfileInput
    skills?: FreelancerSkillCreateNestedManyWithoutFreelancerInput
  }

  export type FreelancerProfileUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: FreelancerSkillUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type FreelancerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFreelancerProfileNestedInput
    skills?: FreelancerSkillUpdateManyWithoutFreelancerNestedInput
  }

  export type FreelancerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: FreelancerSkillUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type FreelancerProfileCreateManyInput = {
    id?: string
    userId: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
  }

  export type ClientProfileUncheckedCreateInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
  }

  export type ClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateManyInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancers?: FreelancerSkillCreateNestedManyWithoutSkillInput
    projects?: ProjectSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancers?: FreelancerSkillUncheckedCreateNestedManyWithoutSkillInput
    projects?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancers?: FreelancerSkillUpdateManyWithoutSkillNestedInput
    projects?: ProjectSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancers?: FreelancerSkillUncheckedUpdateManyWithoutSkillNestedInput
    projects?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillCreateInput = {
    id?: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: FreelancerProfileCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutFreelancersInput
  }

  export type FreelancerSkillUncheckedCreateInput = {
    id?: string
    freelancerId: string
    skillId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: FreelancerProfileUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutFreelancersNestedInput
  }

  export type FreelancerSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillCreateManyInput = {
    id?: string
    freelancerId: string
    skillId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    bids?: BidCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutProjectsInput
  }

  export type ProjectSkillUncheckedCreateInput = {
    id?: string
    projectId: string
    skillId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillCreateManyInput = {
    id?: string
    projectId: string
    skillId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateInput = {
    id?: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBidsInput
    freelancer: UserCreateNestedOneWithoutBidsInput
    contract?: ContractCreateNestedOneWithoutBidInput
  }

  export type BidUncheckedCreateInput = {
    id?: string
    projectId: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutBidInput
  }

  export type BidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBidsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutBidsNestedInput
    contract?: ContractUpdateOneWithoutBidNestedInput
  }

  export type BidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutBidNestedInput
  }

  export type BidCreateManyInput = {
    id?: string
    projectId: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    bid: BidCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    contractId: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    contractId: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    project?: ProjectCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    project?: ProjectUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutReviewsInput
    fromUser: UserCreateNestedOneWithoutGivenReviewsInput
    toUser: UserCreateNestedOneWithoutReceivedReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    contractId: string
    fromUserId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutReviewsNestedInput
    fromUser?: UserUpdateOneRequiredWithoutGivenReviewsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    contractId: string
    fromUserId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionCreateInput = {
    id?: string
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: UserCreateNestedOneWithoutPerformedActionsInput
    user?: UserCreateNestedOneWithoutAdminActionsInput
    project?: ProjectCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionUncheckedCreateInput = {
    id?: string
    adminId: string
    userId?: string | null
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutPerformedActionsNestedInput
    user?: UserUpdateOneWithoutAdminActionsNestedInput
    project?: ProjectUpdateOneWithoutAdminActionsNestedInput
  }

  export type AdminActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionCreateManyInput = {
    id?: string
    adminId: string
    userId?: string | null
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigCreateInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: UserCreateNestedOneWithoutGigsInput
    reviews?: GigReviewCreateNestedManyWithoutGigInput
    orders?: GigOrderCreateNestedManyWithoutGigInput
  }

  export type GigUncheckedCreateInput = {
    id?: string
    freelancerId: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: GigReviewUncheckedCreateNestedManyWithoutGigInput
    orders?: GigOrderUncheckedCreateNestedManyWithoutGigInput
  }

  export type GigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: UserUpdateOneRequiredWithoutGigsNestedInput
    reviews?: GigReviewUpdateManyWithoutGigNestedInput
    orders?: GigOrderUpdateManyWithoutGigNestedInput
  }

  export type GigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: GigReviewUncheckedUpdateManyWithoutGigNestedInput
    orders?: GigOrderUncheckedUpdateManyWithoutGigNestedInput
  }

  export type GigCreateManyInput = {
    id?: string
    freelancerId: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderCreateInput = {
    id?: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    gig: GigCreateNestedOneWithoutOrdersInput
    client: UserCreateNestedOneWithoutGigOrdersInput
  }

  export type GigOrderUncheckedCreateInput = {
    id?: string
    gigId: string
    clientId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gig?: GigUpdateOneRequiredWithoutOrdersNestedInput
    client?: UserUpdateOneRequiredWithoutGigOrdersNestedInput
  }

  export type GigOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderCreateManyInput = {
    id?: string
    gigId: string
    clientId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gig: GigCreateNestedOneWithoutReviewsInput
    client: UserCreateNestedOneWithoutGigReviewsInput
  }

  export type GigReviewUncheckedCreateInput = {
    id?: string
    gigId: string
    clientId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gig?: GigUpdateOneRequiredWithoutReviewsNestedInput
    client?: UserUpdateOneRequiredWithoutGigReviewsNestedInput
  }

  export type GigReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewCreateManyInput = {
    id?: string
    gigId: string
    clientId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FreelancerProfileNullableRelationFilter = {
    is?: FreelancerProfileWhereInput | null
    isNot?: FreelancerProfileWhereInput | null
  }

  export type ClientProfileNullableRelationFilter = {
    is?: ClientProfileWhereInput | null
    isNot?: ClientProfileWhereInput | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type BidListRelationFilter = {
    every?: BidWhereInput
    some?: BidWhereInput
    none?: BidWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AdminActionListRelationFilter = {
    every?: AdminActionWhereInput
    some?: AdminActionWhereInput
    none?: AdminActionWhereInput
  }

  export type GigListRelationFilter = {
    every?: GigWhereInput
    some?: GigWhereInput
    none?: GigWhereInput
  }

  export type GigOrderListRelationFilter = {
    every?: GigOrderWhereInput
    some?: GigOrderWhereInput
    none?: GigOrderWhereInput
  }

  export type GigReviewListRelationFilter = {
    every?: GigReviewWhereInput
    some?: GigReviewWhereInput
    none?: GigReviewWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GigOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GigReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FreelancerSkillListRelationFilter = {
    every?: FreelancerSkillWhereInput
    some?: FreelancerSkillWhereInput
    none?: FreelancerSkillWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FreelancerSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelancerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    location?: SortOrder
    languages?: SortOrder
    portfolio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerProfileAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type FreelancerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    education?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerProfileSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSkillListRelationFilter = {
    every?: ProjectSkillWhereInput
    some?: ProjectSkillWhereInput
    none?: ProjectSkillWhereInput
  }

  export type ProjectSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerProfileRelationFilter = {
    is?: FreelancerProfileWhereInput
    isNot?: FreelancerProfileWhereInput
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type FreelancerSkillFreelancerIdSkillIdCompoundUniqueInput = {
    freelancerId: string
    skillId: string
  }

  export type FreelancerSkillCountOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    skillId?: SortOrder
    yearsExperience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerSkillAvgOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type FreelancerSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    skillId?: SortOrder
    yearsExperience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerSkillMinOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    skillId?: SortOrder
    yearsExperience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelancerSkillSumOrderByAggregateInput = {
    yearsExperience?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type ContractNullableRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    budget?: SortOrder
    deadline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectSkillProjectIdSkillIdCompoundUniqueInput = {
    projectId: string
    skillId: string
  }

  export type ProjectSkillCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSkillMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type BidProjectIdFreelancerIdCompoundUniqueInput = {
    projectId: string
    freelancerId: string
  }

  export type BidCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    freelancerId?: SortOrder
    amount?: SortOrder
    duration?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidAvgOrderByAggregateInput = {
    amount?: SortOrder
    duration?: SortOrder
  }

  export type BidMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    freelancerId?: SortOrder
    amount?: SortOrder
    duration?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    freelancerId?: SortOrder
    amount?: SortOrder
    duration?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidSumOrderByAggregateInput = {
    amount?: SortOrder
    duration?: SortOrder
  }

  export type EnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type BidRelationFilter = {
    is?: BidWhereInput
    isNot?: BidWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bidId?: SortOrder
    clientId?: SortOrder
    freelancerId?: SortOrder
    terms?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bidId?: SortOrder
    clientId?: SortOrder
    freelancerId?: SortOrder
    terms?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    bidId?: SortOrder
    clientId?: SortOrder
    freelancerId?: SortOrder
    terms?: SortOrder
    amount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type ContractRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    projectId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewContractIdFromUserIdToUserIdCompoundUniqueInput = {
    contractId: string
    fromUserId: string
    toUserId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumAdminActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeFilter<$PrismaModel> | $Enums.AdminActionType
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AdminActionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminActionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminActionTypeFilter<$PrismaModel>
  }

  export type EnumGigStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GigStatus | EnumGigStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigStatusFilter<$PrismaModel> | $Enums.GigStatus
  }

  export type GigCountOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    requirements?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigAvgOrderByAggregateInput = {
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    rating?: SortOrder
  }

  export type GigMaxOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigMinOrderByAggregateInput = {
    id?: SortOrder
    freelancerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigSumOrderByAggregateInput = {
    price?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    rating?: SortOrder
  }

  export type EnumGigStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GigStatus | EnumGigStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigStatusWithAggregatesFilter<$PrismaModel> | $Enums.GigStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGigStatusFilter<$PrismaModel>
    _max?: NestedEnumGigStatusFilter<$PrismaModel>
  }

  export type EnumGigOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GigOrderStatus | EnumGigOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigOrderStatusFilter<$PrismaModel> | $Enums.GigOrderStatus
  }

  export type GigRelationFilter = {
    is?: GigWhereInput
    isNot?: GigWhereInput
  }

  export type GigOrderCountOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    requirements?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigOrderAvgOrderByAggregateInput = {
    deliveryTime?: SortOrder
    revisions?: SortOrder
  }

  export type GigOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    requirements?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigOrderMinOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    requirements?: SortOrder
    deliveryTime?: SortOrder
    revisions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigOrderSumOrderByAggregateInput = {
    deliveryTime?: SortOrder
    revisions?: SortOrder
  }

  export type EnumGigOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GigOrderStatus | EnumGigOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.GigOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGigOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumGigOrderStatusFilter<$PrismaModel>
  }

  export type GigReviewGigIdClientIdCompoundUniqueInput = {
    gigId: string
    clientId: string
  }

  export type GigReviewCountOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type GigReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigReviewMinOrderByAggregateInput = {
    id?: SortOrder
    gigId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GigReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FreelancerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutUserInput
    connect?: FreelancerProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type BidCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput> | BidCreateWithoutFreelancerInput[] | BidUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: BidCreateOrConnectWithoutFreelancerInput | BidCreateOrConnectWithoutFreelancerInput[]
    createMany?: BidCreateManyFreelancerInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutClientInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput> | ContractCreateWithoutClientInput[] | ContractUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput | ContractCreateOrConnectWithoutClientInput[]
    createMany?: ContractCreateManyClientInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput> | ContractCreateWithoutFreelancerInput[] | ContractUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutFreelancerInput | ContractCreateOrConnectWithoutFreelancerInput[]
    createMany?: ContractCreateManyFreelancerInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutFromUserInput = {
    create?: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput> | ReviewCreateWithoutFromUserInput[] | ReviewUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutFromUserInput | ReviewCreateOrConnectWithoutFromUserInput[]
    createMany?: ReviewCreateManyFromUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutToUserInput = {
    create?: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput> | ReviewCreateWithoutToUserInput[] | ReviewUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutToUserInput | ReviewCreateOrConnectWithoutToUserInput[]
    createMany?: ReviewCreateManyToUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminActionCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput> | AdminActionCreateWithoutUserInput[] | AdminActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutUserInput | AdminActionCreateOrConnectWithoutUserInput[]
    createMany?: AdminActionCreateManyUserInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type AdminActionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type GigCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput> | GigCreateWithoutFreelancerInput[] | GigUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: GigCreateOrConnectWithoutFreelancerInput | GigCreateOrConnectWithoutFreelancerInput[]
    createMany?: GigCreateManyFreelancerInputEnvelope
    connect?: GigWhereUniqueInput | GigWhereUniqueInput[]
  }

  export type GigOrderCreateNestedManyWithoutClientInput = {
    create?: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput> | GigOrderCreateWithoutClientInput[] | GigOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutClientInput | GigOrderCreateOrConnectWithoutClientInput[]
    createMany?: GigOrderCreateManyClientInputEnvelope
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
  }

  export type GigReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput> | GigReviewCreateWithoutClientInput[] | GigReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutClientInput | GigReviewCreateOrConnectWithoutClientInput[]
    createMany?: GigReviewCreateManyClientInputEnvelope
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
  }

  export type FreelancerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutUserInput
    connect?: FreelancerProfileWhereUniqueInput
  }

  export type ClientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput> | BidCreateWithoutFreelancerInput[] | BidUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: BidCreateOrConnectWithoutFreelancerInput | BidCreateOrConnectWithoutFreelancerInput[]
    createMany?: BidCreateManyFreelancerInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput> | ContractCreateWithoutClientInput[] | ContractUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput | ContractCreateOrConnectWithoutClientInput[]
    createMany?: ContractCreateManyClientInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput> | ContractCreateWithoutFreelancerInput[] | ContractUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutFreelancerInput | ContractCreateOrConnectWithoutFreelancerInput[]
    createMany?: ContractCreateManyFreelancerInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput> | ReviewCreateWithoutFromUserInput[] | ReviewUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutFromUserInput | ReviewCreateOrConnectWithoutFromUserInput[]
    createMany?: ReviewCreateManyFromUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput> | ReviewCreateWithoutToUserInput[] | ReviewUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutToUserInput | ReviewCreateOrConnectWithoutToUserInput[]
    createMany?: ReviewCreateManyToUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput> | AdminActionCreateWithoutUserInput[] | AdminActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutUserInput | AdminActionCreateOrConnectWithoutUserInput[]
    createMany?: AdminActionCreateManyUserInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type AdminActionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type GigUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput> | GigCreateWithoutFreelancerInput[] | GigUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: GigCreateOrConnectWithoutFreelancerInput | GigCreateOrConnectWithoutFreelancerInput[]
    createMany?: GigCreateManyFreelancerInputEnvelope
    connect?: GigWhereUniqueInput | GigWhereUniqueInput[]
  }

  export type GigOrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput> | GigOrderCreateWithoutClientInput[] | GigOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutClientInput | GigOrderCreateOrConnectWithoutClientInput[]
    createMany?: GigOrderCreateManyClientInputEnvelope
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
  }

  export type GigReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput> | GigReviewCreateWithoutClientInput[] | GigReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutClientInput | GigReviewCreateOrConnectWithoutClientInput[]
    createMany?: GigReviewCreateManyClientInputEnvelope
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FreelancerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutUserInput
    upsert?: FreelancerProfileUpsertWithoutUserInput
    disconnect?: FreelancerProfileWhereInput | boolean
    delete?: FreelancerProfileWhereInput | boolean
    connect?: FreelancerProfileWhereUniqueInput
    update?: XOR<XOR<FreelancerProfileUpdateToOneWithWhereWithoutUserInput, FreelancerProfileUpdateWithoutUserInput>, FreelancerProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type BidUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput> | BidCreateWithoutFreelancerInput[] | BidUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: BidCreateOrConnectWithoutFreelancerInput | BidCreateOrConnectWithoutFreelancerInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutFreelancerInput | BidUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: BidCreateManyFreelancerInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutFreelancerInput | BidUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: BidUpdateManyWithWhereWithoutFreelancerInput | BidUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput> | ContractCreateWithoutClientInput[] | ContractUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput | ContractCreateOrConnectWithoutClientInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutClientInput | ContractUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContractCreateManyClientInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutClientInput | ContractUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutClientInput | ContractUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput> | ContractCreateWithoutFreelancerInput[] | ContractUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutFreelancerInput | ContractCreateOrConnectWithoutFreelancerInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutFreelancerInput | ContractUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: ContractCreateManyFreelancerInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutFreelancerInput | ContractUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutFreelancerInput | ContractUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput> | ReviewCreateWithoutFromUserInput[] | ReviewUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutFromUserInput | ReviewCreateOrConnectWithoutFromUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutFromUserInput | ReviewUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: ReviewCreateManyFromUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutFromUserInput | ReviewUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutFromUserInput | ReviewUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutToUserNestedInput = {
    create?: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput> | ReviewCreateWithoutToUserInput[] | ReviewUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutToUserInput | ReviewCreateOrConnectWithoutToUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutToUserInput | ReviewUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: ReviewCreateManyToUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutToUserInput | ReviewUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutToUserInput | ReviewUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AdminActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput> | AdminActionCreateWithoutUserInput[] | AdminActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutUserInput | AdminActionCreateOrConnectWithoutUserInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutUserInput | AdminActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminActionCreateManyUserInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutUserInput | AdminActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutUserInput | AdminActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type AdminActionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutAdminInput | AdminActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutAdminInput | AdminActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutAdminInput | AdminActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type GigUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput> | GigCreateWithoutFreelancerInput[] | GigUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: GigCreateOrConnectWithoutFreelancerInput | GigCreateOrConnectWithoutFreelancerInput[]
    upsert?: GigUpsertWithWhereUniqueWithoutFreelancerInput | GigUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: GigCreateManyFreelancerInputEnvelope
    set?: GigWhereUniqueInput | GigWhereUniqueInput[]
    disconnect?: GigWhereUniqueInput | GigWhereUniqueInput[]
    delete?: GigWhereUniqueInput | GigWhereUniqueInput[]
    connect?: GigWhereUniqueInput | GigWhereUniqueInput[]
    update?: GigUpdateWithWhereUniqueWithoutFreelancerInput | GigUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: GigUpdateManyWithWhereWithoutFreelancerInput | GigUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: GigScalarWhereInput | GigScalarWhereInput[]
  }

  export type GigOrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput> | GigOrderCreateWithoutClientInput[] | GigOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutClientInput | GigOrderCreateOrConnectWithoutClientInput[]
    upsert?: GigOrderUpsertWithWhereUniqueWithoutClientInput | GigOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GigOrderCreateManyClientInputEnvelope
    set?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    disconnect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    delete?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    update?: GigOrderUpdateWithWhereUniqueWithoutClientInput | GigOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GigOrderUpdateManyWithWhereWithoutClientInput | GigOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
  }

  export type GigReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput> | GigReviewCreateWithoutClientInput[] | GigReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutClientInput | GigReviewCreateOrConnectWithoutClientInput[]
    upsert?: GigReviewUpsertWithWhereUniqueWithoutClientInput | GigReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GigReviewCreateManyClientInputEnvelope
    set?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    disconnect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    delete?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    update?: GigReviewUpdateWithWhereUniqueWithoutClientInput | GigReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GigReviewUpdateManyWithWhereWithoutClientInput | GigReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
  }

  export type FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutUserInput
    upsert?: FreelancerProfileUpsertWithoutUserInput
    disconnect?: FreelancerProfileWhereInput | boolean
    delete?: FreelancerProfileWhereInput | boolean
    connect?: FreelancerProfileWhereUniqueInput
    update?: XOR<XOR<FreelancerProfileUpdateToOneWithWhereWithoutUserInput, FreelancerProfileUpdateWithoutUserInput>, FreelancerProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput> | BidCreateWithoutFreelancerInput[] | BidUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: BidCreateOrConnectWithoutFreelancerInput | BidCreateOrConnectWithoutFreelancerInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutFreelancerInput | BidUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: BidCreateManyFreelancerInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutFreelancerInput | BidUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: BidUpdateManyWithWhereWithoutFreelancerInput | BidUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput> | ContractCreateWithoutClientInput[] | ContractUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput | ContractCreateOrConnectWithoutClientInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutClientInput | ContractUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContractCreateManyClientInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutClientInput | ContractUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutClientInput | ContractUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput> | ContractCreateWithoutFreelancerInput[] | ContractUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutFreelancerInput | ContractCreateOrConnectWithoutFreelancerInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutFreelancerInput | ContractUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: ContractCreateManyFreelancerInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutFreelancerInput | ContractUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutFreelancerInput | ContractUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput> | ReviewCreateWithoutFromUserInput[] | ReviewUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutFromUserInput | ReviewCreateOrConnectWithoutFromUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutFromUserInput | ReviewUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: ReviewCreateManyFromUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutFromUserInput | ReviewUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutFromUserInput | ReviewUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput> | ReviewCreateWithoutToUserInput[] | ReviewUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutToUserInput | ReviewCreateOrConnectWithoutToUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutToUserInput | ReviewUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: ReviewCreateManyToUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutToUserInput | ReviewUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutToUserInput | ReviewUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AdminActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput> | AdminActionCreateWithoutUserInput[] | AdminActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutUserInput | AdminActionCreateOrConnectWithoutUserInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutUserInput | AdminActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminActionCreateManyUserInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutUserInput | AdminActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutUserInput | AdminActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type AdminActionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutAdminInput | AdminActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutAdminInput | AdminActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutAdminInput | AdminActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type GigUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput> | GigCreateWithoutFreelancerInput[] | GigUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: GigCreateOrConnectWithoutFreelancerInput | GigCreateOrConnectWithoutFreelancerInput[]
    upsert?: GigUpsertWithWhereUniqueWithoutFreelancerInput | GigUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: GigCreateManyFreelancerInputEnvelope
    set?: GigWhereUniqueInput | GigWhereUniqueInput[]
    disconnect?: GigWhereUniqueInput | GigWhereUniqueInput[]
    delete?: GigWhereUniqueInput | GigWhereUniqueInput[]
    connect?: GigWhereUniqueInput | GigWhereUniqueInput[]
    update?: GigUpdateWithWhereUniqueWithoutFreelancerInput | GigUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: GigUpdateManyWithWhereWithoutFreelancerInput | GigUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: GigScalarWhereInput | GigScalarWhereInput[]
  }

  export type GigOrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput> | GigOrderCreateWithoutClientInput[] | GigOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutClientInput | GigOrderCreateOrConnectWithoutClientInput[]
    upsert?: GigOrderUpsertWithWhereUniqueWithoutClientInput | GigOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GigOrderCreateManyClientInputEnvelope
    set?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    disconnect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    delete?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    update?: GigOrderUpdateWithWhereUniqueWithoutClientInput | GigOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GigOrderUpdateManyWithWhereWithoutClientInput | GigOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
  }

  export type GigReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput> | GigReviewCreateWithoutClientInput[] | GigReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutClientInput | GigReviewCreateOrConnectWithoutClientInput[]
    upsert?: GigReviewUpsertWithWhereUniqueWithoutClientInput | GigReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GigReviewCreateManyClientInputEnvelope
    set?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    disconnect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    delete?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    update?: GigReviewUpdateWithWhereUniqueWithoutClientInput | GigReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GigReviewUpdateManyWithWhereWithoutClientInput | GigReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
  }

  export type FreelancerProfileCreatelanguagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFreelancerProfileInput = {
    create?: XOR<UserCreateWithoutFreelancerProfileInput, UserUncheckedCreateWithoutFreelancerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelancerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type FreelancerSkillCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput> | FreelancerSkillCreateWithoutFreelancerInput[] | FreelancerSkillUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutFreelancerInput | FreelancerSkillCreateOrConnectWithoutFreelancerInput[]
    createMany?: FreelancerSkillCreateManyFreelancerInputEnvelope
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
  }

  export type FreelancerSkillUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput> | FreelancerSkillCreateWithoutFreelancerInput[] | FreelancerSkillUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutFreelancerInput | FreelancerSkillCreateOrConnectWithoutFreelancerInput[]
    createMany?: FreelancerSkillCreateManyFreelancerInputEnvelope
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FreelancerProfileUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutFreelancerProfileNestedInput = {
    create?: XOR<UserCreateWithoutFreelancerProfileInput, UserUncheckedCreateWithoutFreelancerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelancerProfileInput
    upsert?: UserUpsertWithoutFreelancerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFreelancerProfileInput, UserUpdateWithoutFreelancerProfileInput>, UserUncheckedUpdateWithoutFreelancerProfileInput>
  }

  export type FreelancerSkillUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput> | FreelancerSkillCreateWithoutFreelancerInput[] | FreelancerSkillUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutFreelancerInput | FreelancerSkillCreateOrConnectWithoutFreelancerInput[]
    upsert?: FreelancerSkillUpsertWithWhereUniqueWithoutFreelancerInput | FreelancerSkillUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: FreelancerSkillCreateManyFreelancerInputEnvelope
    set?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    disconnect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    delete?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    update?: FreelancerSkillUpdateWithWhereUniqueWithoutFreelancerInput | FreelancerSkillUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: FreelancerSkillUpdateManyWithWhereWithoutFreelancerInput | FreelancerSkillUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
  }

  export type FreelancerSkillUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput> | FreelancerSkillCreateWithoutFreelancerInput[] | FreelancerSkillUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutFreelancerInput | FreelancerSkillCreateOrConnectWithoutFreelancerInput[]
    upsert?: FreelancerSkillUpsertWithWhereUniqueWithoutFreelancerInput | FreelancerSkillUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: FreelancerSkillCreateManyFreelancerInputEnvelope
    set?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    disconnect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    delete?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    update?: FreelancerSkillUpdateWithWhereUniqueWithoutFreelancerInput | FreelancerSkillUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: FreelancerSkillUpdateManyWithWhereWithoutFreelancerInput | FreelancerSkillUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type FreelancerSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput> | FreelancerSkillCreateWithoutSkillInput[] | FreelancerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutSkillInput | FreelancerSkillCreateOrConnectWithoutSkillInput[]
    createMany?: FreelancerSkillCreateManySkillInputEnvelope
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
  }

  export type ProjectSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type FreelancerSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput> | FreelancerSkillCreateWithoutSkillInput[] | FreelancerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutSkillInput | FreelancerSkillCreateOrConnectWithoutSkillInput[]
    createMany?: FreelancerSkillCreateManySkillInputEnvelope
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
  }

  export type ProjectSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type FreelancerSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput> | FreelancerSkillCreateWithoutSkillInput[] | FreelancerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutSkillInput | FreelancerSkillCreateOrConnectWithoutSkillInput[]
    upsert?: FreelancerSkillUpsertWithWhereUniqueWithoutSkillInput | FreelancerSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: FreelancerSkillCreateManySkillInputEnvelope
    set?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    disconnect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    delete?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    update?: FreelancerSkillUpdateWithWhereUniqueWithoutSkillInput | FreelancerSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: FreelancerSkillUpdateManyWithWhereWithoutSkillInput | FreelancerSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
  }

  export type ProjectSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutSkillInput | ProjectSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutSkillInput | ProjectSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutSkillInput | ProjectSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type FreelancerSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput> | FreelancerSkillCreateWithoutSkillInput[] | FreelancerSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: FreelancerSkillCreateOrConnectWithoutSkillInput | FreelancerSkillCreateOrConnectWithoutSkillInput[]
    upsert?: FreelancerSkillUpsertWithWhereUniqueWithoutSkillInput | FreelancerSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: FreelancerSkillCreateManySkillInputEnvelope
    set?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    disconnect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    delete?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    connect?: FreelancerSkillWhereUniqueInput | FreelancerSkillWhereUniqueInput[]
    update?: FreelancerSkillUpdateWithWhereUniqueWithoutSkillInput | FreelancerSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: FreelancerSkillUpdateManyWithWhereWithoutSkillInput | FreelancerSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
  }

  export type ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput> | ProjectSkillCreateWithoutSkillInput[] | ProjectSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutSkillInput | ProjectSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutSkillInput | ProjectSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ProjectSkillCreateManySkillInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutSkillInput | ProjectSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutSkillInput | ProjectSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type FreelancerProfileCreateNestedOneWithoutSkillsInput = {
    create?: XOR<FreelancerProfileCreateWithoutSkillsInput, FreelancerProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutSkillsInput
    connect?: FreelancerProfileWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutFreelancersInput = {
    create?: XOR<SkillCreateWithoutFreelancersInput, SkillUncheckedCreateWithoutFreelancersInput>
    connectOrCreate?: SkillCreateOrConnectWithoutFreelancersInput
    connect?: SkillWhereUniqueInput
  }

  export type FreelancerProfileUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<FreelancerProfileCreateWithoutSkillsInput, FreelancerProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: FreelancerProfileCreateOrConnectWithoutSkillsInput
    upsert?: FreelancerProfileUpsertWithoutSkillsInput
    connect?: FreelancerProfileWhereUniqueInput
    update?: XOR<XOR<FreelancerProfileUpdateToOneWithWhereWithoutSkillsInput, FreelancerProfileUpdateWithoutSkillsInput>, FreelancerProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutFreelancersNestedInput = {
    create?: XOR<SkillCreateWithoutFreelancersInput, SkillUncheckedCreateWithoutFreelancersInput>
    connectOrCreate?: SkillCreateOrConnectWithoutFreelancersInput
    upsert?: SkillUpsertWithoutFreelancersInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutFreelancersInput, SkillUpdateWithoutFreelancersInput>, SkillUncheckedUpdateWithoutFreelancersInput>
  }

  export type UserCreateNestedOneWithoutPostedProjectsInput = {
    create?: XOR<UserCreateWithoutPostedProjectsInput, UserUncheckedCreateWithoutPostedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectSkillCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type BidCreateNestedManyWithoutProjectInput = {
    create?: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput> | BidCreateWithoutProjectInput[] | BidUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BidCreateOrConnectWithoutProjectInput | BidCreateOrConnectWithoutProjectInput[]
    createMany?: BidCreateManyProjectInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutProjectInput = {
    create?: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput> | MessageCreateWithoutProjectInput[] | MessageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutProjectInput | MessageCreateOrConnectWithoutProjectInput[]
    createMany?: MessageCreateManyProjectInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContractCreateNestedOneWithoutProjectInput = {
    create?: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContractCreateOrConnectWithoutProjectInput
    connect?: ContractWhereUniqueInput
  }

  export type AdminActionCreateNestedManyWithoutProjectInput = {
    create?: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput> | AdminActionCreateWithoutProjectInput[] | AdminActionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutProjectInput | AdminActionCreateOrConnectWithoutProjectInput[]
    createMany?: AdminActionCreateManyProjectInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type ProjectSkillUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput> | BidCreateWithoutProjectInput[] | BidUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BidCreateOrConnectWithoutProjectInput | BidCreateOrConnectWithoutProjectInput[]
    createMany?: BidCreateManyProjectInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput> | MessageCreateWithoutProjectInput[] | MessageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutProjectInput | MessageCreateOrConnectWithoutProjectInput[]
    createMany?: MessageCreateManyProjectInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContractCreateOrConnectWithoutProjectInput
    connect?: ContractWhereUniqueInput
  }

  export type AdminActionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput> | AdminActionCreateWithoutProjectInput[] | AdminActionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutProjectInput | AdminActionCreateOrConnectWithoutProjectInput[]
    createMany?: AdminActionCreateManyProjectInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type UserUpdateOneRequiredWithoutPostedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutPostedProjectsInput, UserUncheckedCreateWithoutPostedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostedProjectsInput
    upsert?: UserUpsertWithoutPostedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostedProjectsInput, UserUpdateWithoutPostedProjectsInput>, UserUncheckedUpdateWithoutPostedProjectsInput>
  }

  export type ProjectSkillUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutProjectInput | ProjectSkillUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutProjectInput | ProjectSkillUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutProjectInput | ProjectSkillUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type BidUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput> | BidCreateWithoutProjectInput[] | BidUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BidCreateOrConnectWithoutProjectInput | BidCreateOrConnectWithoutProjectInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutProjectInput | BidUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BidCreateManyProjectInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutProjectInput | BidUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BidUpdateManyWithWhereWithoutProjectInput | BidUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput> | MessageCreateWithoutProjectInput[] | MessageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutProjectInput | MessageCreateOrConnectWithoutProjectInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutProjectInput | MessageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MessageCreateManyProjectInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutProjectInput | MessageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutProjectInput | MessageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContractUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContractCreateOrConnectWithoutProjectInput
    upsert?: ContractUpsertWithoutProjectInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutProjectInput, ContractUpdateWithoutProjectInput>, ContractUncheckedUpdateWithoutProjectInput>
  }

  export type AdminActionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput> | AdminActionCreateWithoutProjectInput[] | AdminActionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutProjectInput | AdminActionCreateOrConnectWithoutProjectInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutProjectInput | AdminActionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AdminActionCreateManyProjectInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutProjectInput | AdminActionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutProjectInput | AdminActionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput> | ProjectSkillCreateWithoutProjectInput[] | ProjectSkillUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSkillCreateOrConnectWithoutProjectInput | ProjectSkillCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSkillUpsertWithWhereUniqueWithoutProjectInput | ProjectSkillUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSkillCreateManyProjectInputEnvelope
    set?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    disconnect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    delete?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    connect?: ProjectSkillWhereUniqueInput | ProjectSkillWhereUniqueInput[]
    update?: ProjectSkillUpdateWithWhereUniqueWithoutProjectInput | ProjectSkillUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSkillUpdateManyWithWhereWithoutProjectInput | ProjectSkillUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput> | BidCreateWithoutProjectInput[] | BidUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BidCreateOrConnectWithoutProjectInput | BidCreateOrConnectWithoutProjectInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutProjectInput | BidUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BidCreateManyProjectInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutProjectInput | BidUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BidUpdateManyWithWhereWithoutProjectInput | BidUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput> | MessageCreateWithoutProjectInput[] | MessageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutProjectInput | MessageCreateOrConnectWithoutProjectInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutProjectInput | MessageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MessageCreateManyProjectInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutProjectInput | MessageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutProjectInput | MessageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContractUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContractCreateOrConnectWithoutProjectInput
    upsert?: ContractUpsertWithoutProjectInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutProjectInput, ContractUpdateWithoutProjectInput>, ContractUncheckedUpdateWithoutProjectInput>
  }

  export type AdminActionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput> | AdminActionCreateWithoutProjectInput[] | AdminActionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutProjectInput | AdminActionCreateOrConnectWithoutProjectInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutProjectInput | AdminActionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AdminActionCreateManyProjectInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutProjectInput | AdminActionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutProjectInput | AdminActionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput
    connect?: ProjectWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutProjectsInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput
    connect?: SkillWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput
    upsert?: ProjectUpsertWithoutSkillsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSkillsInput, ProjectUpdateWithoutSkillsInput>, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput
    upsert?: SkillUpsertWithoutProjectsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutProjectsInput, SkillUpdateWithoutProjectsInput>, SkillUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectCreateNestedOneWithoutBidsInput = {
    create?: XOR<ProjectCreateWithoutBidsInput, ProjectUncheckedCreateWithoutBidsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBidsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBidsInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    connect?: UserWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutBidInput = {
    create?: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
    connectOrCreate?: ContractCreateOrConnectWithoutBidInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUncheckedCreateNestedOneWithoutBidInput = {
    create?: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
    connectOrCreate?: ContractCreateOrConnectWithoutBidInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumBidStatusFieldUpdateOperationsInput = {
    set?: $Enums.BidStatus
  }

  export type ProjectUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<ProjectCreateWithoutBidsInput, ProjectUncheckedCreateWithoutBidsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBidsInput
    upsert?: ProjectUpsertWithoutBidsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBidsInput, ProjectUpdateWithoutBidsInput>, ProjectUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBidsInput
    upsert?: UserUpsertWithoutBidsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBidsInput, UserUpdateWithoutBidsInput>, UserUncheckedUpdateWithoutBidsInput>
  }

  export type ContractUpdateOneWithoutBidNestedInput = {
    create?: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
    connectOrCreate?: ContractCreateOrConnectWithoutBidInput
    upsert?: ContractUpsertWithoutBidInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutBidInput, ContractUpdateWithoutBidInput>, ContractUncheckedUpdateWithoutBidInput>
  }

  export type ContractUncheckedUpdateOneWithoutBidNestedInput = {
    create?: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
    connectOrCreate?: ContractCreateOrConnectWithoutBidInput
    upsert?: ContractUpsertWithoutBidInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutBidInput, ContractUpdateWithoutBidInput>, ContractUncheckedUpdateWithoutBidInput>
  }

  export type ProjectCreateNestedOneWithoutContractInput = {
    create?: XOR<ProjectCreateWithoutContractInput, ProjectUncheckedCreateWithoutContractInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutContractInput
    connect?: ProjectWhereUniqueInput
  }

  export type BidCreateNestedOneWithoutContractInput = {
    create?: XOR<BidCreateWithoutContractInput, BidUncheckedCreateWithoutContractInput>
    connectOrCreate?: BidCreateOrConnectWithoutContractInput
    connect?: BidWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientContractsInput = {
    create?: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContractsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFreelancerContractsInput = {
    create?: XOR<UserCreateWithoutFreelancerContractsInput, UserUncheckedCreateWithoutFreelancerContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelancerContractsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutContractInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutContractInput = {
    create?: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput> | ReviewCreateWithoutContractInput[] | ReviewUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractInput | ReviewCreateOrConnectWithoutContractInput[]
    createMany?: ReviewCreateManyContractInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput> | ReviewCreateWithoutContractInput[] | ReviewUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractInput | ReviewCreateOrConnectWithoutContractInput[]
    createMany?: ReviewCreateManyContractInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus
  }

  export type ProjectUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<ProjectCreateWithoutContractInput, ProjectUncheckedCreateWithoutContractInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutContractInput
    upsert?: ProjectUpsertWithoutContractInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutContractInput, ProjectUpdateWithoutContractInput>, ProjectUncheckedUpdateWithoutContractInput>
  }

  export type BidUpdateOneRequiredWithoutContractNestedInput = {
    create?: XOR<BidCreateWithoutContractInput, BidUncheckedCreateWithoutContractInput>
    connectOrCreate?: BidCreateOrConnectWithoutContractInput
    upsert?: BidUpsertWithoutContractInput
    connect?: BidWhereUniqueInput
    update?: XOR<XOR<BidUpdateToOneWithWhereWithoutContractInput, BidUpdateWithoutContractInput>, BidUncheckedUpdateWithoutContractInput>
  }

  export type UserUpdateOneRequiredWithoutClientContractsNestedInput = {
    create?: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientContractsInput
    upsert?: UserUpsertWithoutClientContractsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientContractsInput, UserUpdateWithoutClientContractsInput>, UserUncheckedUpdateWithoutClientContractsInput>
  }

  export type UserUpdateOneRequiredWithoutFreelancerContractsNestedInput = {
    create?: XOR<UserCreateWithoutFreelancerContractsInput, UserUncheckedCreateWithoutFreelancerContractsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFreelancerContractsInput
    upsert?: UserUpsertWithoutFreelancerContractsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFreelancerContractsInput, UserUpdateWithoutFreelancerContractsInput>, UserUncheckedUpdateWithoutFreelancerContractsInput>
  }

  export type PaymentUpdateManyWithoutContractNestedInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractInput | PaymentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractInput | PaymentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractInput | PaymentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutContractNestedInput = {
    create?: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput> | ReviewCreateWithoutContractInput[] | ReviewUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractInput | ReviewCreateOrConnectWithoutContractInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutContractInput | ReviewUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ReviewCreateManyContractInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutContractInput | ReviewUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutContractInput | ReviewUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractInput | PaymentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractInput | PaymentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractInput | PaymentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput> | ReviewCreateWithoutContractInput[] | ReviewUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutContractInput | ReviewCreateOrConnectWithoutContractInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutContractInput | ReviewUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ReviewCreateManyContractInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutContractInput | ReviewUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutContractInput | ReviewUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPaymentsInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ContractUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPaymentsInput
    upsert?: ContractUpsertWithoutPaymentsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutPaymentsInput, ContractUpdateWithoutPaymentsInput>, ContractUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMessagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type ProjectUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMessagesInput
    upsert?: ProjectUpsertWithoutMessagesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMessagesInput, ProjectUpdateWithoutMessagesInput>, ProjectUncheckedUpdateWithoutMessagesInput>
  }

  export type ContractCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ContractCreateWithoutReviewsInput, ContractUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutReviewsInput
    connect?: ContractWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGivenReviewsInput = {
    create?: XOR<UserCreateWithoutGivenReviewsInput, UserUncheckedCreateWithoutGivenReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedReviewsInput = {
    create?: XOR<UserCreateWithoutReceivedReviewsInput, UserUncheckedCreateWithoutReceivedReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ContractCreateWithoutReviewsInput, ContractUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutReviewsInput
    upsert?: ContractUpsertWithoutReviewsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutReviewsInput, ContractUpdateWithoutReviewsInput>, ContractUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutGivenReviewsNestedInput = {
    create?: XOR<UserCreateWithoutGivenReviewsInput, UserUncheckedCreateWithoutGivenReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenReviewsInput
    upsert?: UserUpsertWithoutGivenReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGivenReviewsInput, UserUpdateWithoutGivenReviewsInput>, UserUncheckedUpdateWithoutGivenReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedReviewsInput, UserUncheckedCreateWithoutReceivedReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedReviewsInput
    upsert?: UserUpsertWithoutReceivedReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedReviewsInput, UserUpdateWithoutReceivedReviewsInput>, UserUncheckedUpdateWithoutReceivedReviewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPerformedActionsInput = {
    create?: XOR<UserCreateWithoutPerformedActionsInput, UserUncheckedCreateWithoutPerformedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformedActionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminActionsInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAdminActionsInput = {
    create?: XOR<ProjectCreateWithoutAdminActionsInput, ProjectUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAdminActionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumAdminActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdminActionType
  }

  export type UserUpdateOneRequiredWithoutPerformedActionsNestedInput = {
    create?: XOR<UserCreateWithoutPerformedActionsInput, UserUncheckedCreateWithoutPerformedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformedActionsInput
    upsert?: UserUpsertWithoutPerformedActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformedActionsInput, UserUpdateWithoutPerformedActionsInput>, UserUncheckedUpdateWithoutPerformedActionsInput>
  }

  export type UserUpdateOneWithoutAdminActionsNestedInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    upsert?: UserUpsertWithoutAdminActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminActionsInput, UserUpdateWithoutAdminActionsInput>, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type ProjectUpdateOneWithoutAdminActionsNestedInput = {
    create?: XOR<ProjectCreateWithoutAdminActionsInput, ProjectUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAdminActionsInput
    upsert?: ProjectUpsertWithoutAdminActionsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAdminActionsInput, ProjectUpdateWithoutAdminActionsInput>, ProjectUncheckedUpdateWithoutAdminActionsInput>
  }

  export type GigCreatetagsInput = {
    set: string[]
  }

  export type GigCreateimagesInput = {
    set: string[]
  }

  export type GigCreaterequirementsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutGigsInput = {
    create?: XOR<UserCreateWithoutGigsInput, UserUncheckedCreateWithoutGigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigsInput
    connect?: UserWhereUniqueInput
  }

  export type GigReviewCreateNestedManyWithoutGigInput = {
    create?: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput> | GigReviewCreateWithoutGigInput[] | GigReviewUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutGigInput | GigReviewCreateOrConnectWithoutGigInput[]
    createMany?: GigReviewCreateManyGigInputEnvelope
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
  }

  export type GigOrderCreateNestedManyWithoutGigInput = {
    create?: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput> | GigOrderCreateWithoutGigInput[] | GigOrderUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutGigInput | GigOrderCreateOrConnectWithoutGigInput[]
    createMany?: GigOrderCreateManyGigInputEnvelope
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
  }

  export type GigReviewUncheckedCreateNestedManyWithoutGigInput = {
    create?: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput> | GigReviewCreateWithoutGigInput[] | GigReviewUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutGigInput | GigReviewCreateOrConnectWithoutGigInput[]
    createMany?: GigReviewCreateManyGigInputEnvelope
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
  }

  export type GigOrderUncheckedCreateNestedManyWithoutGigInput = {
    create?: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput> | GigOrderCreateWithoutGigInput[] | GigOrderUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutGigInput | GigOrderCreateOrConnectWithoutGigInput[]
    createMany?: GigOrderCreateManyGigInputEnvelope
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
  }

  export type GigUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GigUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GigUpdaterequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumGigStatusFieldUpdateOperationsInput = {
    set?: $Enums.GigStatus
  }

  export type UserUpdateOneRequiredWithoutGigsNestedInput = {
    create?: XOR<UserCreateWithoutGigsInput, UserUncheckedCreateWithoutGigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigsInput
    upsert?: UserUpsertWithoutGigsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGigsInput, UserUpdateWithoutGigsInput>, UserUncheckedUpdateWithoutGigsInput>
  }

  export type GigReviewUpdateManyWithoutGigNestedInput = {
    create?: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput> | GigReviewCreateWithoutGigInput[] | GigReviewUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutGigInput | GigReviewCreateOrConnectWithoutGigInput[]
    upsert?: GigReviewUpsertWithWhereUniqueWithoutGigInput | GigReviewUpsertWithWhereUniqueWithoutGigInput[]
    createMany?: GigReviewCreateManyGigInputEnvelope
    set?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    disconnect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    delete?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    update?: GigReviewUpdateWithWhereUniqueWithoutGigInput | GigReviewUpdateWithWhereUniqueWithoutGigInput[]
    updateMany?: GigReviewUpdateManyWithWhereWithoutGigInput | GigReviewUpdateManyWithWhereWithoutGigInput[]
    deleteMany?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
  }

  export type GigOrderUpdateManyWithoutGigNestedInput = {
    create?: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput> | GigOrderCreateWithoutGigInput[] | GigOrderUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutGigInput | GigOrderCreateOrConnectWithoutGigInput[]
    upsert?: GigOrderUpsertWithWhereUniqueWithoutGigInput | GigOrderUpsertWithWhereUniqueWithoutGigInput[]
    createMany?: GigOrderCreateManyGigInputEnvelope
    set?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    disconnect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    delete?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    update?: GigOrderUpdateWithWhereUniqueWithoutGigInput | GigOrderUpdateWithWhereUniqueWithoutGigInput[]
    updateMany?: GigOrderUpdateManyWithWhereWithoutGigInput | GigOrderUpdateManyWithWhereWithoutGigInput[]
    deleteMany?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
  }

  export type GigReviewUncheckedUpdateManyWithoutGigNestedInput = {
    create?: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput> | GigReviewCreateWithoutGigInput[] | GigReviewUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigReviewCreateOrConnectWithoutGigInput | GigReviewCreateOrConnectWithoutGigInput[]
    upsert?: GigReviewUpsertWithWhereUniqueWithoutGigInput | GigReviewUpsertWithWhereUniqueWithoutGigInput[]
    createMany?: GigReviewCreateManyGigInputEnvelope
    set?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    disconnect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    delete?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    connect?: GigReviewWhereUniqueInput | GigReviewWhereUniqueInput[]
    update?: GigReviewUpdateWithWhereUniqueWithoutGigInput | GigReviewUpdateWithWhereUniqueWithoutGigInput[]
    updateMany?: GigReviewUpdateManyWithWhereWithoutGigInput | GigReviewUpdateManyWithWhereWithoutGigInput[]
    deleteMany?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
  }

  export type GigOrderUncheckedUpdateManyWithoutGigNestedInput = {
    create?: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput> | GigOrderCreateWithoutGigInput[] | GigOrderUncheckedCreateWithoutGigInput[]
    connectOrCreate?: GigOrderCreateOrConnectWithoutGigInput | GigOrderCreateOrConnectWithoutGigInput[]
    upsert?: GigOrderUpsertWithWhereUniqueWithoutGigInput | GigOrderUpsertWithWhereUniqueWithoutGigInput[]
    createMany?: GigOrderCreateManyGigInputEnvelope
    set?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    disconnect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    delete?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    connect?: GigOrderWhereUniqueInput | GigOrderWhereUniqueInput[]
    update?: GigOrderUpdateWithWhereUniqueWithoutGigInput | GigOrderUpdateWithWhereUniqueWithoutGigInput[]
    updateMany?: GigOrderUpdateManyWithWhereWithoutGigInput | GigOrderUpdateManyWithWhereWithoutGigInput[]
    deleteMany?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
  }

  export type GigCreateNestedOneWithoutOrdersInput = {
    create?: XOR<GigCreateWithoutOrdersInput, GigUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: GigCreateOrConnectWithoutOrdersInput
    connect?: GigWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGigOrdersInput = {
    create?: XOR<UserCreateWithoutGigOrdersInput, UserUncheckedCreateWithoutGigOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGigOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.GigOrderStatus
  }

  export type GigUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<GigCreateWithoutOrdersInput, GigUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: GigCreateOrConnectWithoutOrdersInput
    upsert?: GigUpsertWithoutOrdersInput
    connect?: GigWhereUniqueInput
    update?: XOR<XOR<GigUpdateToOneWithWhereWithoutOrdersInput, GigUpdateWithoutOrdersInput>, GigUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutGigOrdersNestedInput = {
    create?: XOR<UserCreateWithoutGigOrdersInput, UserUncheckedCreateWithoutGigOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigOrdersInput
    upsert?: UserUpsertWithoutGigOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGigOrdersInput, UserUpdateWithoutGigOrdersInput>, UserUncheckedUpdateWithoutGigOrdersInput>
  }

  export type GigCreateNestedOneWithoutReviewsInput = {
    create?: XOR<GigCreateWithoutReviewsInput, GigUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GigCreateOrConnectWithoutReviewsInput
    connect?: GigWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGigReviewsInput = {
    create?: XOR<UserCreateWithoutGigReviewsInput, UserUncheckedCreateWithoutGigReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type GigUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<GigCreateWithoutReviewsInput, GigUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: GigCreateOrConnectWithoutReviewsInput
    upsert?: GigUpsertWithoutReviewsInput
    connect?: GigWhereUniqueInput
    update?: XOR<XOR<GigUpdateToOneWithWhereWithoutReviewsInput, GigUpdateWithoutReviewsInput>, GigUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutGigReviewsNestedInput = {
    create?: XOR<UserCreateWithoutGigReviewsInput, UserUncheckedCreateWithoutGigReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGigReviewsInput
    upsert?: UserUpsertWithoutGigReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGigReviewsInput, UserUpdateWithoutGigReviewsInput>, UserUncheckedUpdateWithoutGigReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumBidStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusFilter<$PrismaModel> | $Enums.BidStatus
  }

  export type NestedEnumBidStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BidStatus | EnumBidStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BidStatus[] | ListEnumBidStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBidStatusWithAggregatesFilter<$PrismaModel> | $Enums.BidStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBidStatusFilter<$PrismaModel>
    _max?: NestedEnumBidStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdminActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeFilter<$PrismaModel> | $Enums.AdminActionType
  }

  export type NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminActionType | EnumAdminActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminActionType[] | ListEnumAdminActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumGigStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GigStatus | EnumGigStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigStatusFilter<$PrismaModel> | $Enums.GigStatus
  }

  export type NestedEnumGigStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GigStatus | EnumGigStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigStatus[] | ListEnumGigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigStatusWithAggregatesFilter<$PrismaModel> | $Enums.GigStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGigStatusFilter<$PrismaModel>
    _max?: NestedEnumGigStatusFilter<$PrismaModel>
  }

  export type NestedEnumGigOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GigOrderStatus | EnumGigOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigOrderStatusFilter<$PrismaModel> | $Enums.GigOrderStatus
  }

  export type NestedEnumGigOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GigOrderStatus | EnumGigOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GigOrderStatus[] | ListEnumGigOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGigOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.GigOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGigOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumGigOrderStatusFilter<$PrismaModel>
  }

  export type FreelancerProfileCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: FreelancerSkillCreateNestedManyWithoutFreelancerInput
  }

  export type FreelancerProfileUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: FreelancerSkillUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type FreelancerProfileCreateOrConnectWithoutUserInput = {
    where: FreelancerProfileWhereUniqueInput
    create: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
  }

  export type ClientProfileCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileCreateOrConnectWithoutUserInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    bids?: BidCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type BidCreateWithoutFreelancerInput = {
    id?: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBidsInput
    contract?: ContractCreateNestedOneWithoutBidInput
  }

  export type BidUncheckedCreateWithoutFreelancerInput = {
    id?: string
    projectId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutBidInput
  }

  export type BidCreateOrConnectWithoutFreelancerInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput>
  }

  export type BidCreateManyFreelancerInputEnvelope = {
    data: BidCreateManyFreelancerInput | BidCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutClientInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    bid: BidCreateNestedOneWithoutContractInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutClientInput = {
    id?: string
    projectId: string
    bidId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutClientInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
  }

  export type ContractCreateManyClientInputEnvelope = {
    data: ContractCreateManyClientInput | ContractCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutFreelancerInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    bid: BidCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutFreelancerInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutFreelancerInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput>
  }

  export type ContractCreateManyFreelancerInputEnvelope = {
    data: ContractCreateManyFreelancerInput | ContractCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    project?: ProjectCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    project?: ProjectCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutFromUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutReviewsInput
    toUser: UserCreateNestedOneWithoutReceivedReviewsInput
  }

  export type ReviewUncheckedCreateWithoutFromUserInput = {
    id?: string
    contractId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutFromUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput>
  }

  export type ReviewCreateManyFromUserInputEnvelope = {
    data: ReviewCreateManyFromUserInput | ReviewCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutToUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutReviewsInput
    fromUser: UserCreateNestedOneWithoutGivenReviewsInput
  }

  export type ReviewUncheckedCreateWithoutToUserInput = {
    id?: string
    contractId: string
    fromUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutToUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput>
  }

  export type ReviewCreateManyToUserInputEnvelope = {
    data: ReviewCreateManyToUserInput | ReviewCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminActionCreateWithoutUserInput = {
    id?: string
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: UserCreateNestedOneWithoutPerformedActionsInput
    project?: ProjectCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionUncheckedCreateWithoutUserInput = {
    id?: string
    adminId: string
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateOrConnectWithoutUserInput = {
    where: AdminActionWhereUniqueInput
    create: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput>
  }

  export type AdminActionCreateManyUserInputEnvelope = {
    data: AdminActionCreateManyUserInput | AdminActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminActionCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminActionsInput
    project?: ProjectCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionUncheckedCreateWithoutAdminInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateOrConnectWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    create: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionCreateManyAdminInputEnvelope = {
    data: AdminActionCreateManyAdminInput | AdminActionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type GigCreateWithoutFreelancerInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: GigReviewCreateNestedManyWithoutGigInput
    orders?: GigOrderCreateNestedManyWithoutGigInput
  }

  export type GigUncheckedCreateWithoutFreelancerInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: GigReviewUncheckedCreateNestedManyWithoutGigInput
    orders?: GigOrderUncheckedCreateNestedManyWithoutGigInput
  }

  export type GigCreateOrConnectWithoutFreelancerInput = {
    where: GigWhereUniqueInput
    create: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput>
  }

  export type GigCreateManyFreelancerInputEnvelope = {
    data: GigCreateManyFreelancerInput | GigCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type GigOrderCreateWithoutClientInput = {
    id?: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    gig: GigCreateNestedOneWithoutOrdersInput
  }

  export type GigOrderUncheckedCreateWithoutClientInput = {
    id?: string
    gigId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderCreateOrConnectWithoutClientInput = {
    where: GigOrderWhereUniqueInput
    create: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput>
  }

  export type GigOrderCreateManyClientInputEnvelope = {
    data: GigOrderCreateManyClientInput | GigOrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type GigReviewCreateWithoutClientInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gig: GigCreateNestedOneWithoutReviewsInput
  }

  export type GigReviewUncheckedCreateWithoutClientInput = {
    id?: string
    gigId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewCreateOrConnectWithoutClientInput = {
    where: GigReviewWhereUniqueInput
    create: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput>
  }

  export type GigReviewCreateManyClientInputEnvelope = {
    data: GigReviewCreateManyClientInput | GigReviewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FreelancerProfileUpsertWithoutUserInput = {
    update: XOR<FreelancerProfileUpdateWithoutUserInput, FreelancerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<FreelancerProfileCreateWithoutUserInput, FreelancerProfileUncheckedCreateWithoutUserInput>
    where?: FreelancerProfileWhereInput
  }

  export type FreelancerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: FreelancerProfileWhereInput
    data: XOR<FreelancerProfileUpdateWithoutUserInput, FreelancerProfileUncheckedUpdateWithoutUserInput>
  }

  export type FreelancerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: FreelancerSkillUpdateManyWithoutFreelancerNestedInput
  }

  export type FreelancerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: FreelancerSkillUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type ClientProfileUpsertWithoutUserInput = {
    update: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    budget?: FloatFilter<"Project"> | number
    deadline?: DateTimeFilter<"Project"> | Date | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type BidUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutFreelancerInput, BidUncheckedUpdateWithoutFreelancerInput>
    create: XOR<BidCreateWithoutFreelancerInput, BidUncheckedCreateWithoutFreelancerInput>
  }

  export type BidUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutFreelancerInput, BidUncheckedUpdateWithoutFreelancerInput>
  }

  export type BidUpdateManyWithWhereWithoutFreelancerInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type BidScalarWhereInput = {
    AND?: BidScalarWhereInput | BidScalarWhereInput[]
    OR?: BidScalarWhereInput[]
    NOT?: BidScalarWhereInput | BidScalarWhereInput[]
    id?: StringFilter<"Bid"> | string
    projectId?: StringFilter<"Bid"> | string
    freelancerId?: StringFilter<"Bid"> | string
    amount?: FloatFilter<"Bid"> | number
    duration?: IntFilter<"Bid"> | number
    coverLetter?: StringFilter<"Bid"> | string
    status?: EnumBidStatusFilter<"Bid"> | $Enums.BidStatus
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    updatedAt?: DateTimeFilter<"Bid"> | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutClientInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutClientInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
  }

  export type ContractUpdateManyWithWhereWithoutClientInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutClientInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    projectId?: StringFilter<"Contract"> | string
    bidId?: StringFilter<"Contract"> | string
    clientId?: StringFilter<"Contract"> | string
    freelancerId?: StringFilter<"Contract"> | string
    terms?: StringFilter<"Contract"> | string
    amount?: FloatFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutFreelancerInput, ContractUncheckedUpdateWithoutFreelancerInput>
    create: XOR<ContractCreateWithoutFreelancerInput, ContractUncheckedCreateWithoutFreelancerInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutFreelancerInput, ContractUncheckedUpdateWithoutFreelancerInput>
  }

  export type ContractUpdateManyWithWhereWithoutFreelancerInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    projectId?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutFromUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutFromUserInput, ReviewUncheckedUpdateWithoutFromUserInput>
    create: XOR<ReviewCreateWithoutFromUserInput, ReviewUncheckedCreateWithoutFromUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutFromUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutFromUserInput, ReviewUncheckedUpdateWithoutFromUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutFromUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutFromUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    contractId?: StringFilter<"Review"> | string
    fromUserId?: StringFilter<"Review"> | string
    toUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutToUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutToUserInput, ReviewUncheckedUpdateWithoutToUserInput>
    create: XOR<ReviewCreateWithoutToUserInput, ReviewUncheckedCreateWithoutToUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutToUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutToUserInput, ReviewUncheckedUpdateWithoutToUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutToUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AdminActionUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminActionWhereUniqueInput
    update: XOR<AdminActionUpdateWithoutUserInput, AdminActionUncheckedUpdateWithoutUserInput>
    create: XOR<AdminActionCreateWithoutUserInput, AdminActionUncheckedCreateWithoutUserInput>
  }

  export type AdminActionUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminActionWhereUniqueInput
    data: XOR<AdminActionUpdateWithoutUserInput, AdminActionUncheckedUpdateWithoutUserInput>
  }

  export type AdminActionUpdateManyWithWhereWithoutUserInput = {
    where: AdminActionScalarWhereInput
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminActionScalarWhereInput = {
    AND?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
    OR?: AdminActionScalarWhereInput[]
    NOT?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
    id?: StringFilter<"AdminAction"> | string
    adminId?: StringFilter<"AdminAction"> | string
    userId?: StringNullableFilter<"AdminAction"> | string | null
    projectId?: StringNullableFilter<"AdminAction"> | string | null
    action?: EnumAdminActionTypeFilter<"AdminAction"> | $Enums.AdminActionType
    reason?: StringFilter<"AdminAction"> | string
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAction"> | Date | string
  }

  export type AdminActionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    update: XOR<AdminActionUpdateWithoutAdminInput, AdminActionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    data: XOR<AdminActionUpdateWithoutAdminInput, AdminActionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminActionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminActionScalarWhereInput
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyWithoutAdminInput>
  }

  export type GigUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: GigWhereUniqueInput
    update: XOR<GigUpdateWithoutFreelancerInput, GigUncheckedUpdateWithoutFreelancerInput>
    create: XOR<GigCreateWithoutFreelancerInput, GigUncheckedCreateWithoutFreelancerInput>
  }

  export type GigUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: GigWhereUniqueInput
    data: XOR<GigUpdateWithoutFreelancerInput, GigUncheckedUpdateWithoutFreelancerInput>
  }

  export type GigUpdateManyWithWhereWithoutFreelancerInput = {
    where: GigScalarWhereInput
    data: XOR<GigUpdateManyMutationInput, GigUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type GigScalarWhereInput = {
    AND?: GigScalarWhereInput | GigScalarWhereInput[]
    OR?: GigScalarWhereInput[]
    NOT?: GigScalarWhereInput | GigScalarWhereInput[]
    id?: StringFilter<"Gig"> | string
    freelancerId?: StringFilter<"Gig"> | string
    title?: StringFilter<"Gig"> | string
    description?: StringFilter<"Gig"> | string
    price?: FloatFilter<"Gig"> | number
    deliveryTime?: IntFilter<"Gig"> | number
    revisions?: IntFilter<"Gig"> | number
    category?: StringFilter<"Gig"> | string
    subcategory?: StringFilter<"Gig"> | string
    tags?: StringNullableListFilter<"Gig">
    images?: StringNullableListFilter<"Gig">
    requirements?: StringNullableListFilter<"Gig">
    status?: EnumGigStatusFilter<"Gig"> | $Enums.GigStatus
    rating?: FloatFilter<"Gig"> | number
    createdAt?: DateTimeFilter<"Gig"> | Date | string
    updatedAt?: DateTimeFilter<"Gig"> | Date | string
  }

  export type GigOrderUpsertWithWhereUniqueWithoutClientInput = {
    where: GigOrderWhereUniqueInput
    update: XOR<GigOrderUpdateWithoutClientInput, GigOrderUncheckedUpdateWithoutClientInput>
    create: XOR<GigOrderCreateWithoutClientInput, GigOrderUncheckedCreateWithoutClientInput>
  }

  export type GigOrderUpdateWithWhereUniqueWithoutClientInput = {
    where: GigOrderWhereUniqueInput
    data: XOR<GigOrderUpdateWithoutClientInput, GigOrderUncheckedUpdateWithoutClientInput>
  }

  export type GigOrderUpdateManyWithWhereWithoutClientInput = {
    where: GigOrderScalarWhereInput
    data: XOR<GigOrderUpdateManyMutationInput, GigOrderUncheckedUpdateManyWithoutClientInput>
  }

  export type GigOrderScalarWhereInput = {
    AND?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
    OR?: GigOrderScalarWhereInput[]
    NOT?: GigOrderScalarWhereInput | GigOrderScalarWhereInput[]
    id?: StringFilter<"GigOrder"> | string
    gigId?: StringFilter<"GigOrder"> | string
    clientId?: StringFilter<"GigOrder"> | string
    requirements?: StringFilter<"GigOrder"> | string
    deliveryTime?: IntFilter<"GigOrder"> | number
    revisions?: IntFilter<"GigOrder"> | number
    status?: EnumGigOrderStatusFilter<"GigOrder"> | $Enums.GigOrderStatus
    createdAt?: DateTimeFilter<"GigOrder"> | Date | string
    updatedAt?: DateTimeFilter<"GigOrder"> | Date | string
  }

  export type GigReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: GigReviewWhereUniqueInput
    update: XOR<GigReviewUpdateWithoutClientInput, GigReviewUncheckedUpdateWithoutClientInput>
    create: XOR<GigReviewCreateWithoutClientInput, GigReviewUncheckedCreateWithoutClientInput>
  }

  export type GigReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: GigReviewWhereUniqueInput
    data: XOR<GigReviewUpdateWithoutClientInput, GigReviewUncheckedUpdateWithoutClientInput>
  }

  export type GigReviewUpdateManyWithWhereWithoutClientInput = {
    where: GigReviewScalarWhereInput
    data: XOR<GigReviewUpdateManyMutationInput, GigReviewUncheckedUpdateManyWithoutClientInput>
  }

  export type GigReviewScalarWhereInput = {
    AND?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
    OR?: GigReviewScalarWhereInput[]
    NOT?: GigReviewScalarWhereInput | GigReviewScalarWhereInput[]
    id?: StringFilter<"GigReview"> | string
    gigId?: StringFilter<"GigReview"> | string
    clientId?: StringFilter<"GigReview"> | string
    rating?: IntFilter<"GigReview"> | number
    comment?: StringFilter<"GigReview"> | string
    createdAt?: DateTimeFilter<"GigReview"> | Date | string
    updatedAt?: DateTimeFilter<"GigReview"> | Date | string
  }

  export type UserCreateWithoutFreelancerProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutFreelancerProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutFreelancerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFreelancerProfileInput, UserUncheckedCreateWithoutFreelancerProfileInput>
  }

  export type FreelancerSkillCreateWithoutFreelancerInput = {
    id?: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutFreelancersInput
  }

  export type FreelancerSkillUncheckedCreateWithoutFreelancerInput = {
    id?: string
    skillId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillCreateOrConnectWithoutFreelancerInput = {
    where: FreelancerSkillWhereUniqueInput
    create: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput>
  }

  export type FreelancerSkillCreateManyFreelancerInputEnvelope = {
    data: FreelancerSkillCreateManyFreelancerInput | FreelancerSkillCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFreelancerProfileInput = {
    update: XOR<UserUpdateWithoutFreelancerProfileInput, UserUncheckedUpdateWithoutFreelancerProfileInput>
    create: XOR<UserCreateWithoutFreelancerProfileInput, UserUncheckedCreateWithoutFreelancerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFreelancerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFreelancerProfileInput, UserUncheckedUpdateWithoutFreelancerProfileInput>
  }

  export type UserUpdateWithoutFreelancerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutFreelancerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type FreelancerSkillUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: FreelancerSkillWhereUniqueInput
    update: XOR<FreelancerSkillUpdateWithoutFreelancerInput, FreelancerSkillUncheckedUpdateWithoutFreelancerInput>
    create: XOR<FreelancerSkillCreateWithoutFreelancerInput, FreelancerSkillUncheckedCreateWithoutFreelancerInput>
  }

  export type FreelancerSkillUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: FreelancerSkillWhereUniqueInput
    data: XOR<FreelancerSkillUpdateWithoutFreelancerInput, FreelancerSkillUncheckedUpdateWithoutFreelancerInput>
  }

  export type FreelancerSkillUpdateManyWithWhereWithoutFreelancerInput = {
    where: FreelancerSkillScalarWhereInput
    data: XOR<FreelancerSkillUpdateManyMutationInput, FreelancerSkillUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type FreelancerSkillScalarWhereInput = {
    AND?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
    OR?: FreelancerSkillScalarWhereInput[]
    NOT?: FreelancerSkillScalarWhereInput | FreelancerSkillScalarWhereInput[]
    id?: StringFilter<"FreelancerSkill"> | string
    freelancerId?: StringFilter<"FreelancerSkill"> | string
    skillId?: StringFilter<"FreelancerSkill"> | string
    yearsExperience?: IntFilter<"FreelancerSkill"> | number
    createdAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
    updatedAt?: DateTimeFilter<"FreelancerSkill"> | Date | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type FreelancerSkillCreateWithoutSkillInput = {
    id?: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: FreelancerProfileCreateNestedOneWithoutSkillsInput
  }

  export type FreelancerSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    freelancerId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillCreateOrConnectWithoutSkillInput = {
    where: FreelancerSkillWhereUniqueInput
    create: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput>
  }

  export type FreelancerSkillCreateManySkillInputEnvelope = {
    data: FreelancerSkillCreateManySkillInput | FreelancerSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSkillCreateWithoutSkillInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSkillsInput
  }

  export type ProjectSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillCreateOrConnectWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    create: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput>
  }

  export type ProjectSkillCreateManySkillInputEnvelope = {
    data: ProjectSkillCreateManySkillInput | ProjectSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type FreelancerSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: FreelancerSkillWhereUniqueInput
    update: XOR<FreelancerSkillUpdateWithoutSkillInput, FreelancerSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<FreelancerSkillCreateWithoutSkillInput, FreelancerSkillUncheckedCreateWithoutSkillInput>
  }

  export type FreelancerSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: FreelancerSkillWhereUniqueInput
    data: XOR<FreelancerSkillUpdateWithoutSkillInput, FreelancerSkillUncheckedUpdateWithoutSkillInput>
  }

  export type FreelancerSkillUpdateManyWithWhereWithoutSkillInput = {
    where: FreelancerSkillScalarWhereInput
    data: XOR<FreelancerSkillUpdateManyMutationInput, FreelancerSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ProjectSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    update: XOR<ProjectSkillUpdateWithoutSkillInput, ProjectSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ProjectSkillCreateWithoutSkillInput, ProjectSkillUncheckedCreateWithoutSkillInput>
  }

  export type ProjectSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ProjectSkillWhereUniqueInput
    data: XOR<ProjectSkillUpdateWithoutSkillInput, ProjectSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ProjectSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ProjectSkillScalarWhereInput
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ProjectSkillScalarWhereInput = {
    AND?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
    OR?: ProjectSkillScalarWhereInput[]
    NOT?: ProjectSkillScalarWhereInput | ProjectSkillScalarWhereInput[]
    id?: StringFilter<"ProjectSkill"> | string
    projectId?: StringFilter<"ProjectSkill"> | string
    skillId?: StringFilter<"ProjectSkill"> | string
    createdAt?: DateTimeFilter<"ProjectSkill"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSkill"> | Date | string
  }

  export type FreelancerProfileCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFreelancerProfileInput
  }

  export type FreelancerProfileUncheckedCreateWithoutSkillsInput = {
    id?: string
    userId: string
    title: string
    description: string
    experience: number
    education?: string | null
    location: string
    languages?: FreelancerProfileCreatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerProfileCreateOrConnectWithoutSkillsInput = {
    where: FreelancerProfileWhereUniqueInput
    create: XOR<FreelancerProfileCreateWithoutSkillsInput, FreelancerProfileUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutFreelancersInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutFreelancersInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutFreelancersInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutFreelancersInput, SkillUncheckedCreateWithoutFreelancersInput>
  }

  export type FreelancerProfileUpsertWithoutSkillsInput = {
    update: XOR<FreelancerProfileUpdateWithoutSkillsInput, FreelancerProfileUncheckedUpdateWithoutSkillsInput>
    create: XOR<FreelancerProfileCreateWithoutSkillsInput, FreelancerProfileUncheckedCreateWithoutSkillsInput>
    where?: FreelancerProfileWhereInput
  }

  export type FreelancerProfileUpdateToOneWithWhereWithoutSkillsInput = {
    where?: FreelancerProfileWhereInput
    data: XOR<FreelancerProfileUpdateWithoutSkillsInput, FreelancerProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type FreelancerProfileUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFreelancerProfileNestedInput
  }

  export type FreelancerProfileUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    languages?: FreelancerProfileUpdatelanguagesInput | string[]
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUpsertWithoutFreelancersInput = {
    update: XOR<SkillUpdateWithoutFreelancersInput, SkillUncheckedUpdateWithoutFreelancersInput>
    create: XOR<SkillCreateWithoutFreelancersInput, SkillUncheckedCreateWithoutFreelancersInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutFreelancersInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutFreelancersInput, SkillUncheckedUpdateWithoutFreelancersInput>
  }

  export type SkillUpdateWithoutFreelancersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutFreelancersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type UserCreateWithoutPostedProjectsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutPostedProjectsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutPostedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostedProjectsInput, UserUncheckedCreateWithoutPostedProjectsInput>
  }

  export type ProjectSkillCreateWithoutProjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutProjectsInput
  }

  export type ProjectSkillUncheckedCreateWithoutProjectInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillCreateOrConnectWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    create: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSkillCreateManyProjectInputEnvelope = {
    data: ProjectSkillCreateManyProjectInput | ProjectSkillCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BidCreateWithoutProjectInput = {
    id?: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: UserCreateNestedOneWithoutBidsInput
    contract?: ContractCreateNestedOneWithoutBidInput
  }

  export type BidUncheckedCreateWithoutProjectInput = {
    id?: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contract?: ContractUncheckedCreateNestedOneWithoutBidInput
  }

  export type BidCreateOrConnectWithoutProjectInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput>
  }

  export type BidCreateManyProjectInputEnvelope = {
    data: BidCreateManyProjectInput | BidCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutProjectInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutProjectInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutProjectInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput>
  }

  export type MessageCreateManyProjectInputEnvelope = {
    data: MessageCreateManyProjectInput | MessageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutProjectInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bid: BidCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutProjectInput = {
    id?: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutProjectInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
  }

  export type AdminActionCreateWithoutProjectInput = {
    id?: string
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: UserCreateNestedOneWithoutPerformedActionsInput
    user?: UserCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionUncheckedCreateWithoutProjectInput = {
    id?: string
    adminId: string
    userId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateOrConnectWithoutProjectInput = {
    where: AdminActionWhereUniqueInput
    create: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput>
  }

  export type AdminActionCreateManyProjectInputEnvelope = {
    data: AdminActionCreateManyProjectInput | AdminActionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostedProjectsInput = {
    update: XOR<UserUpdateWithoutPostedProjectsInput, UserUncheckedUpdateWithoutPostedProjectsInput>
    create: XOR<UserCreateWithoutPostedProjectsInput, UserUncheckedCreateWithoutPostedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostedProjectsInput, UserUncheckedUpdateWithoutPostedProjectsInput>
  }

  export type UserUpdateWithoutPostedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutPostedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectSkillUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    update: XOR<ProjectSkillUpdateWithoutProjectInput, ProjectSkillUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSkillCreateWithoutProjectInput, ProjectSkillUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSkillUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSkillWhereUniqueInput
    data: XOR<ProjectSkillUpdateWithoutProjectInput, ProjectSkillUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSkillUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSkillScalarWhereInput
    data: XOR<ProjectSkillUpdateManyMutationInput, ProjectSkillUncheckedUpdateManyWithoutProjectInput>
  }

  export type BidUpsertWithWhereUniqueWithoutProjectInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutProjectInput, BidUncheckedUpdateWithoutProjectInput>
    create: XOR<BidCreateWithoutProjectInput, BidUncheckedCreateWithoutProjectInput>
  }

  export type BidUpdateWithWhereUniqueWithoutProjectInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutProjectInput, BidUncheckedUpdateWithoutProjectInput>
  }

  export type BidUpdateManyWithWhereWithoutProjectInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutProjectInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutProjectInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutProjectInput, MessageUncheckedUpdateWithoutProjectInput>
    create: XOR<MessageCreateWithoutProjectInput, MessageUncheckedCreateWithoutProjectInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutProjectInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutProjectInput, MessageUncheckedUpdateWithoutProjectInput>
  }

  export type MessageUpdateManyWithWhereWithoutProjectInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutProjectInput>
  }

  export type ContractUpsertWithoutProjectInput = {
    update: XOR<ContractUpdateWithoutProjectInput, ContractUncheckedUpdateWithoutProjectInput>
    create: XOR<ContractCreateWithoutProjectInput, ContractUncheckedCreateWithoutProjectInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutProjectInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutProjectInput, ContractUncheckedUpdateWithoutProjectInput>
  }

  export type ContractUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type AdminActionUpsertWithWhereUniqueWithoutProjectInput = {
    where: AdminActionWhereUniqueInput
    update: XOR<AdminActionUpdateWithoutProjectInput, AdminActionUncheckedUpdateWithoutProjectInput>
    create: XOR<AdminActionCreateWithoutProjectInput, AdminActionUncheckedCreateWithoutProjectInput>
  }

  export type AdminActionUpdateWithWhereUniqueWithoutProjectInput = {
    where: AdminActionWhereUniqueInput
    data: XOR<AdminActionUpdateWithoutProjectInput, AdminActionUncheckedUpdateWithoutProjectInput>
  }

  export type AdminActionUpdateManyWithWhereWithoutProjectInput = {
    where: AdminActionScalarWhereInput
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    bids?: BidCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSkillsInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutProjectsInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancers?: FreelancerSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancers?: FreelancerSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectUpsertWithoutSkillsInput = {
    update: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSkillsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type ProjectUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SkillUpsertWithoutProjectsInput = {
    update: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutProjectsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
  }

  export type SkillUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancers?: FreelancerSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancers?: FreelancerSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type ProjectCreateWithoutBidsInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBidsInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBidsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBidsInput, ProjectUncheckedCreateWithoutBidsInput>
  }

  export type UserCreateWithoutBidsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutBidsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutBidsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
  }

  export type ContractCreateWithoutBidInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutBidInput = {
    id?: string
    projectId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutBidInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
  }

  export type ProjectUpsertWithoutBidsInput = {
    update: XOR<ProjectUpdateWithoutBidsInput, ProjectUncheckedUpdateWithoutBidsInput>
    create: XOR<ProjectCreateWithoutBidsInput, ProjectUncheckedCreateWithoutBidsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBidsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBidsInput, ProjectUncheckedUpdateWithoutBidsInput>
  }

  export type ProjectUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutBidsInput = {
    update: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
    create: XOR<UserCreateWithoutBidsInput, UserUncheckedCreateWithoutBidsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBidsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBidsInput, UserUncheckedUpdateWithoutBidsInput>
  }

  export type UserUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ContractUpsertWithoutBidInput = {
    update: XOR<ContractUpdateWithoutBidInput, ContractUncheckedUpdateWithoutBidInput>
    create: XOR<ContractCreateWithoutBidInput, ContractUncheckedCreateWithoutBidInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutBidInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutBidInput, ContractUncheckedUpdateWithoutBidInput>
  }

  export type ContractUpdateWithoutBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ProjectCreateWithoutContractInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    bids?: BidCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutContractInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutContractInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutContractInput, ProjectUncheckedCreateWithoutContractInput>
  }

  export type BidCreateWithoutContractInput = {
    id?: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBidsInput
    freelancer: UserCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateWithoutContractInput = {
    id?: string
    projectId: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateOrConnectWithoutContractInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutContractInput, BidUncheckedCreateWithoutContractInput>
  }

  export type UserCreateWithoutClientContractsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutClientContractsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutClientContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
  }

  export type UserCreateWithoutFreelancerContractsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutFreelancerContractsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutFreelancerContractsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFreelancerContractsInput, UserUncheckedCreateWithoutFreelancerContractsInput>
  }

  export type PaymentCreateWithoutContractInput = {
    id?: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutContractInput = {
    id?: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutContractInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput>
  }

  export type PaymentCreateManyContractInputEnvelope = {
    data: PaymentCreateManyContractInput | PaymentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutContractInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutGivenReviewsInput
    toUser: UserCreateNestedOneWithoutReceivedReviewsInput
  }

  export type ReviewUncheckedCreateWithoutContractInput = {
    id?: string
    fromUserId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutContractInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput>
  }

  export type ReviewCreateManyContractInputEnvelope = {
    data: ReviewCreateManyContractInput | ReviewCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutContractInput = {
    update: XOR<ProjectUpdateWithoutContractInput, ProjectUncheckedUpdateWithoutContractInput>
    create: XOR<ProjectCreateWithoutContractInput, ProjectUncheckedCreateWithoutContractInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutContractInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutContractInput, ProjectUncheckedUpdateWithoutContractInput>
  }

  export type ProjectUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BidUpsertWithoutContractInput = {
    update: XOR<BidUpdateWithoutContractInput, BidUncheckedUpdateWithoutContractInput>
    create: XOR<BidCreateWithoutContractInput, BidUncheckedCreateWithoutContractInput>
    where?: BidWhereInput
  }

  export type BidUpdateToOneWithWhereWithoutContractInput = {
    where?: BidWhereInput
    data: XOR<BidUpdateWithoutContractInput, BidUncheckedUpdateWithoutContractInput>
  }

  export type BidUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBidsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClientContractsInput = {
    update: XOR<UserUpdateWithoutClientContractsInput, UserUncheckedUpdateWithoutClientContractsInput>
    create: XOR<UserCreateWithoutClientContractsInput, UserUncheckedCreateWithoutClientContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientContractsInput, UserUncheckedUpdateWithoutClientContractsInput>
  }

  export type UserUpdateWithoutClientContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutClientContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutFreelancerContractsInput = {
    update: XOR<UserUpdateWithoutFreelancerContractsInput, UserUncheckedUpdateWithoutFreelancerContractsInput>
    create: XOR<UserCreateWithoutFreelancerContractsInput, UserUncheckedCreateWithoutFreelancerContractsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFreelancerContractsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFreelancerContractsInput, UserUncheckedUpdateWithoutFreelancerContractsInput>
  }

  export type UserUpdateWithoutFreelancerContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutFreelancerContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutContractInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutContractInput, PaymentUncheckedUpdateWithoutContractInput>
    create: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutContractInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutContractInput, PaymentUncheckedUpdateWithoutContractInput>
  }

  export type PaymentUpdateManyWithWhereWithoutContractInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutContractInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    contractId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutContractInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutContractInput, ReviewUncheckedUpdateWithoutContractInput>
    create: XOR<ReviewCreateWithoutContractInput, ReviewUncheckedCreateWithoutContractInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutContractInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutContractInput, ReviewUncheckedUpdateWithoutContractInput>
  }

  export type ReviewUpdateManyWithWhereWithoutContractInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractCreateWithoutPaymentsInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    bid: BidCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    reviews?: ReviewCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutPaymentsInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutPaymentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
  }

  export type ContractUpsertWithoutPaymentsInput = {
    update: XOR<ContractUpdateWithoutPaymentsInput, ContractUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutPaymentsInput, ContractUncheckedUpdateWithoutPaymentsInput>
  }

  export type ContractUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type ProjectCreateWithoutMessagesInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    bids?: BidCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMessagesInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMessagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectUpsertWithoutMessagesInput = {
    update: XOR<ProjectUpdateWithoutMessagesInput, ProjectUncheckedUpdateWithoutMessagesInput>
    create: XOR<ProjectCreateWithoutMessagesInput, ProjectUncheckedCreateWithoutMessagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMessagesInput, ProjectUncheckedUpdateWithoutMessagesInput>
  }

  export type ProjectUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ContractCreateWithoutReviewsInput = {
    id?: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContractInput
    bid: BidCreateNestedOneWithoutContractInput
    client: UserCreateNestedOneWithoutClientContractsInput
    freelancer: UserCreateNestedOneWithoutFreelancerContractsInput
    payments?: PaymentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutReviewsInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutReviewsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutReviewsInput, ContractUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutGivenReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutGivenReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutGivenReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGivenReviewsInput, UserUncheckedCreateWithoutGivenReviewsInput>
  }

  export type UserCreateWithoutReceivedReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutReceivedReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutReceivedReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedReviewsInput, UserUncheckedCreateWithoutReceivedReviewsInput>
  }

  export type ContractUpsertWithoutReviewsInput = {
    update: XOR<ContractUpdateWithoutReviewsInput, ContractUncheckedUpdateWithoutReviewsInput>
    create: XOR<ContractCreateWithoutReviewsInput, ContractUncheckedCreateWithoutReviewsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutReviewsInput, ContractUncheckedUpdateWithoutReviewsInput>
  }

  export type ContractUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type UserUpsertWithoutGivenReviewsInput = {
    update: XOR<UserUpdateWithoutGivenReviewsInput, UserUncheckedUpdateWithoutGivenReviewsInput>
    create: XOR<UserCreateWithoutGivenReviewsInput, UserUncheckedCreateWithoutGivenReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGivenReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGivenReviewsInput, UserUncheckedUpdateWithoutGivenReviewsInput>
  }

  export type UserUpdateWithoutGivenReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutGivenReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutReceivedReviewsInput = {
    update: XOR<UserUpdateWithoutReceivedReviewsInput, UserUncheckedUpdateWithoutReceivedReviewsInput>
    create: XOR<UserCreateWithoutReceivedReviewsInput, UserUncheckedCreateWithoutReceivedReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedReviewsInput, UserUncheckedUpdateWithoutReceivedReviewsInput>
  }

  export type UserUpdateWithoutReceivedReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateWithoutPerformedActionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutPerformedActionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutPerformedActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformedActionsInput, UserUncheckedCreateWithoutPerformedActionsInput>
  }

  export type UserCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutAdminActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
  }

  export type ProjectCreateWithoutAdminActionsInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutPostedProjectsInput
    skills?: ProjectSkillCreateNestedManyWithoutProjectInput
    bids?: BidCreateNestedManyWithoutProjectInput
    messages?: MessageCreateNestedManyWithoutProjectInput
    contract?: ContractCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAdminActionsInput = {
    id?: string
    clientId: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: ProjectSkillUncheckedCreateNestedManyWithoutProjectInput
    bids?: BidUncheckedCreateNestedManyWithoutProjectInput
    messages?: MessageUncheckedCreateNestedManyWithoutProjectInput
    contract?: ContractUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAdminActionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAdminActionsInput, ProjectUncheckedCreateWithoutAdminActionsInput>
  }

  export type UserUpsertWithoutPerformedActionsInput = {
    update: XOR<UserUpdateWithoutPerformedActionsInput, UserUncheckedUpdateWithoutPerformedActionsInput>
    create: XOR<UserCreateWithoutPerformedActionsInput, UserUncheckedCreateWithoutPerformedActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformedActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformedActionsInput, UserUncheckedUpdateWithoutPerformedActionsInput>
  }

  export type UserUpdateWithoutPerformedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutAdminActionsInput = {
    update: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type UserUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectUpsertWithoutAdminActionsInput = {
    update: XOR<ProjectUpdateWithoutAdminActionsInput, ProjectUncheckedUpdateWithoutAdminActionsInput>
    create: XOR<ProjectCreateWithoutAdminActionsInput, ProjectUncheckedCreateWithoutAdminActionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAdminActionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAdminActionsInput, ProjectUncheckedUpdateWithoutAdminActionsInput>
  }

  export type ProjectUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutPostedProjectsNestedInput
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type UserCreateWithoutGigsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutGigsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutGigsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGigsInput, UserUncheckedCreateWithoutGigsInput>
  }

  export type GigReviewCreateWithoutGigInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutGigReviewsInput
  }

  export type GigReviewUncheckedCreateWithoutGigInput = {
    id?: string
    clientId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewCreateOrConnectWithoutGigInput = {
    where: GigReviewWhereUniqueInput
    create: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput>
  }

  export type GigReviewCreateManyGigInputEnvelope = {
    data: GigReviewCreateManyGigInput | GigReviewCreateManyGigInput[]
    skipDuplicates?: boolean
  }

  export type GigOrderCreateWithoutGigInput = {
    id?: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    client: UserCreateNestedOneWithoutGigOrdersInput
  }

  export type GigOrderUncheckedCreateWithoutGigInput = {
    id?: string
    clientId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderCreateOrConnectWithoutGigInput = {
    where: GigOrderWhereUniqueInput
    create: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput>
  }

  export type GigOrderCreateManyGigInputEnvelope = {
    data: GigOrderCreateManyGigInput | GigOrderCreateManyGigInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGigsInput = {
    update: XOR<UserUpdateWithoutGigsInput, UserUncheckedUpdateWithoutGigsInput>
    create: XOR<UserCreateWithoutGigsInput, UserUncheckedCreateWithoutGigsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGigsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGigsInput, UserUncheckedUpdateWithoutGigsInput>
  }

  export type UserUpdateWithoutGigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutGigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type GigReviewUpsertWithWhereUniqueWithoutGigInput = {
    where: GigReviewWhereUniqueInput
    update: XOR<GigReviewUpdateWithoutGigInput, GigReviewUncheckedUpdateWithoutGigInput>
    create: XOR<GigReviewCreateWithoutGigInput, GigReviewUncheckedCreateWithoutGigInput>
  }

  export type GigReviewUpdateWithWhereUniqueWithoutGigInput = {
    where: GigReviewWhereUniqueInput
    data: XOR<GigReviewUpdateWithoutGigInput, GigReviewUncheckedUpdateWithoutGigInput>
  }

  export type GigReviewUpdateManyWithWhereWithoutGigInput = {
    where: GigReviewScalarWhereInput
    data: XOR<GigReviewUpdateManyMutationInput, GigReviewUncheckedUpdateManyWithoutGigInput>
  }

  export type GigOrderUpsertWithWhereUniqueWithoutGigInput = {
    where: GigOrderWhereUniqueInput
    update: XOR<GigOrderUpdateWithoutGigInput, GigOrderUncheckedUpdateWithoutGigInput>
    create: XOR<GigOrderCreateWithoutGigInput, GigOrderUncheckedCreateWithoutGigInput>
  }

  export type GigOrderUpdateWithWhereUniqueWithoutGigInput = {
    where: GigOrderWhereUniqueInput
    data: XOR<GigOrderUpdateWithoutGigInput, GigOrderUncheckedUpdateWithoutGigInput>
  }

  export type GigOrderUpdateManyWithWhereWithoutGigInput = {
    where: GigOrderScalarWhereInput
    data: XOR<GigOrderUpdateManyMutationInput, GigOrderUncheckedUpdateManyWithoutGigInput>
  }

  export type GigCreateWithoutOrdersInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: UserCreateNestedOneWithoutGigsInput
    reviews?: GigReviewCreateNestedManyWithoutGigInput
  }

  export type GigUncheckedCreateWithoutOrdersInput = {
    id?: string
    freelancerId: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: GigReviewUncheckedCreateNestedManyWithoutGigInput
  }

  export type GigCreateOrConnectWithoutOrdersInput = {
    where: GigWhereUniqueInput
    create: XOR<GigCreateWithoutOrdersInput, GigUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutGigOrdersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigReviews?: GigReviewCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutGigOrdersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigReviews?: GigReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutGigOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGigOrdersInput, UserUncheckedCreateWithoutGigOrdersInput>
  }

  export type GigUpsertWithoutOrdersInput = {
    update: XOR<GigUpdateWithoutOrdersInput, GigUncheckedUpdateWithoutOrdersInput>
    create: XOR<GigCreateWithoutOrdersInput, GigUncheckedCreateWithoutOrdersInput>
    where?: GigWhereInput
  }

  export type GigUpdateToOneWithWhereWithoutOrdersInput = {
    where?: GigWhereInput
    data: XOR<GigUpdateWithoutOrdersInput, GigUncheckedUpdateWithoutOrdersInput>
  }

  export type GigUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: UserUpdateOneRequiredWithoutGigsNestedInput
    reviews?: GigReviewUpdateManyWithoutGigNestedInput
  }

  export type GigUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: GigReviewUncheckedUpdateManyWithoutGigNestedInput
  }

  export type UserUpsertWithoutGigOrdersInput = {
    update: XOR<UserUpdateWithoutGigOrdersInput, UserUncheckedUpdateWithoutGigOrdersInput>
    create: XOR<UserCreateWithoutGigOrdersInput, UserUncheckedCreateWithoutGigOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGigOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGigOrdersInput, UserUncheckedUpdateWithoutGigOrdersInput>
  }

  export type UserUpdateWithoutGigOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigReviews?: GigReviewUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutGigOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigReviews?: GigReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type GigCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancer: UserCreateNestedOneWithoutGigsInput
    orders?: GigOrderCreateNestedManyWithoutGigInput
  }

  export type GigUncheckedCreateWithoutReviewsInput = {
    id?: string
    freelancerId: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: GigOrderUncheckedCreateNestedManyWithoutGigInput
  }

  export type GigCreateOrConnectWithoutReviewsInput = {
    where: GigWhereUniqueInput
    create: XOR<GigCreateWithoutReviewsInput, GigUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutGigReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
    postedProjects?: ProjectCreateNestedManyWithoutClientInput
    bids?: BidCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutUserInput
    performedActions?: AdminActionCreateNestedManyWithoutAdminInput
    gigs?: GigCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderCreateNestedManyWithoutClientInput
  }

  export type UserUncheckedCreateWithoutGigReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerProfile?: FreelancerProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
    postedProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    bids?: BidUncheckedCreateNestedManyWithoutFreelancerInput
    clientContracts?: ContractUncheckedCreateNestedManyWithoutClientInput
    freelancerContracts?: ContractUncheckedCreateNestedManyWithoutFreelancerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    givenReviews?: ReviewUncheckedCreateNestedManyWithoutFromUserInput
    receivedReviews?: ReviewUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutUserInput
    performedActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
    gigs?: GigUncheckedCreateNestedManyWithoutFreelancerInput
    gigOrders?: GigOrderUncheckedCreateNestedManyWithoutClientInput
  }

  export type UserCreateOrConnectWithoutGigReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGigReviewsInput, UserUncheckedCreateWithoutGigReviewsInput>
  }

  export type GigUpsertWithoutReviewsInput = {
    update: XOR<GigUpdateWithoutReviewsInput, GigUncheckedUpdateWithoutReviewsInput>
    create: XOR<GigCreateWithoutReviewsInput, GigUncheckedCreateWithoutReviewsInput>
    where?: GigWhereInput
  }

  export type GigUpdateToOneWithWhereWithoutReviewsInput = {
    where?: GigWhereInput
    data: XOR<GigUpdateWithoutReviewsInput, GigUncheckedUpdateWithoutReviewsInput>
  }

  export type GigUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: UserUpdateOneRequiredWithoutGigsNestedInput
    orders?: GigOrderUpdateManyWithoutGigNestedInput
  }

  export type GigUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: GigOrderUncheckedUpdateManyWithoutGigNestedInput
  }

  export type UserUpsertWithoutGigReviewsInput = {
    update: XOR<UserUpdateWithoutGigReviewsInput, UserUncheckedUpdateWithoutGigReviewsInput>
    create: XOR<UserCreateWithoutGigReviewsInput, UserUncheckedCreateWithoutGigReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGigReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGigReviewsInput, UserUncheckedUpdateWithoutGigReviewsInput>
  }

  export type UserUpdateWithoutGigReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUpdateManyWithoutClientNestedInput
    bids?: BidUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUpdateManyWithoutAdminNestedInput
    gigs?: GigUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUpdateManyWithoutClientNestedInput
  }

  export type UserUncheckedUpdateWithoutGigReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerProfile?: FreelancerProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
    postedProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    bids?: BidUncheckedUpdateManyWithoutFreelancerNestedInput
    clientContracts?: ContractUncheckedUpdateManyWithoutClientNestedInput
    freelancerContracts?: ContractUncheckedUpdateManyWithoutFreelancerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    givenReviews?: ReviewUncheckedUpdateManyWithoutFromUserNestedInput
    receivedReviews?: ReviewUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutUserNestedInput
    performedActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
    gigs?: GigUncheckedUpdateManyWithoutFreelancerNestedInput
    gigOrders?: GigOrderUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    title: string
    description: string
    budget: number
    deadline: Date | string
    status?: $Enums.ProjectStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateManyFreelancerInput = {
    id?: string
    projectId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateManyClientInput = {
    id?: string
    projectId: string
    bidId: string
    freelancerId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateManyFreelancerInput = {
    id?: string
    projectId: string
    bidId: string
    clientId: string
    terms: string
    amount: number
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ContractStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiverId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    projectId?: string | null
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyFromUserInput = {
    id?: string
    contractId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyToUserInput = {
    id?: string
    contractId: string
    fromUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateManyUserInput = {
    id?: string
    adminId: string
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateManyAdminInput = {
    id?: string
    userId?: string | null
    projectId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigCreateManyFreelancerInput = {
    id?: string
    title: string
    description: string
    price: number
    deliveryTime: number
    revisions: number
    category: string
    subcategory: string
    tags?: GigCreatetagsInput | string[]
    images?: GigCreateimagesInput | string[]
    requirements?: GigCreaterequirementsInput | string[]
    status?: $Enums.GigStatus
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderCreateManyClientInput = {
    id?: string
    gigId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewCreateManyClientInput = {
    id?: string
    gigId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUpdateManyWithoutProjectNestedInput
    bids?: BidUpdateManyWithoutProjectNestedInput
    messages?: MessageUpdateManyWithoutProjectNestedInput
    contract?: ContractUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: ProjectSkillUncheckedUpdateManyWithoutProjectNestedInput
    bids?: BidUncheckedUpdateManyWithoutProjectNestedInput
    messages?: MessageUncheckedUpdateManyWithoutProjectNestedInput
    contract?: ContractUncheckedUpdateOneWithoutProjectNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBidsNestedInput
    contract?: ContractUpdateOneWithoutBidNestedInput
  }

  export type BidUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutBidNestedInput
  }

  export type BidUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    freelancer?: UserUpdateOneRequiredWithoutFreelancerContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContractNestedInput
    bid?: BidUpdateOneRequiredWithoutContractNestedInput
    client?: UserUpdateOneRequiredWithoutClientContractsNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    reviews?: ReviewUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    bidId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    terms?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    project?: ProjectUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    project?: ProjectUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutReviewsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutReviewsNestedInput
    fromUser?: UserUpdateOneRequiredWithoutGivenReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutPerformedActionsNestedInput
    project?: ProjectUpdateOneWithoutAdminActionsNestedInput
  }

  export type AdminActionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminActionsNestedInput
    project?: ProjectUpdateOneWithoutAdminActionsNestedInput
  }

  export type AdminActionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: GigReviewUpdateManyWithoutGigNestedInput
    orders?: GigOrderUpdateManyWithoutGigNestedInput
  }

  export type GigUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: GigReviewUncheckedUpdateManyWithoutGigNestedInput
    orders?: GigOrderUncheckedUpdateManyWithoutGigNestedInput
  }

  export type GigUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: StringFieldUpdateOperationsInput | string
    tags?: GigUpdatetagsInput | string[]
    images?: GigUpdateimagesInput | string[]
    requirements?: GigUpdaterequirementsInput | string[]
    status?: EnumGigStatusFieldUpdateOperationsInput | $Enums.GigStatus
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gig?: GigUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type GigOrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gig?: GigUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type GigReviewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    gigId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillCreateManyFreelancerInput = {
    id?: string
    skillId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutFreelancersNestedInput
  }

  export type FreelancerSkillUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillCreateManySkillInput = {
    id?: string
    freelancerId: string
    yearsExperience: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillCreateManySkillInput = {
    id?: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelancerSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: FreelancerProfileUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type FreelancerSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelancerSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    yearsExperience?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type ProjectSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillCreateManyProjectInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidCreateManyProjectInput = {
    id?: string
    freelancerId: string
    amount: number
    duration: number
    coverLetter: string
    status?: $Enums.BidStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyProjectInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActionCreateManyProjectInput = {
    id?: string
    adminId: string
    userId?: string | null
    action: $Enums.AdminActionType
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectSkillUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectSkillUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSkillUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancer?: UserUpdateOneRequiredWithoutBidsNestedInput
    contract?: ContractUpdateOneWithoutBidNestedInput
  }

  export type BidUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUncheckedUpdateOneWithoutBidNestedInput
  }

  export type BidUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    freelancerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    coverLetter?: StringFieldUpdateOperationsInput | string
    status?: EnumBidStatusFieldUpdateOperationsInput | $Enums.BidStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutPerformedActionsNestedInput
    user?: UserUpdateOneWithoutAdminActionsNestedInput
  }

  export type AdminActionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAdminActionTypeFieldUpdateOperationsInput | $Enums.AdminActionType
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyContractInput = {
    id?: string
    amount: number
    description: string
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyContractInput = {
    id?: string
    fromUserId: string
    toUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutGivenReviewsNestedInput
    toUser?: UserUpdateOneRequiredWithoutReceivedReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewCreateManyGigInput = {
    id?: string
    clientId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigOrderCreateManyGigInput = {
    id?: string
    clientId: string
    requirements: string
    deliveryTime: number
    revisions: number
    status?: $Enums.GigOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GigReviewUpdateWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutGigReviewsNestedInput
  }

  export type GigReviewUncheckedUpdateWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigReviewUncheckedUpdateManyWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderUpdateWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutGigOrdersNestedInput
  }

  export type GigOrderUncheckedUpdateWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GigOrderUncheckedUpdateManyWithoutGigInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    requirements?: StringFieldUpdateOperationsInput | string
    deliveryTime?: IntFieldUpdateOperationsInput | number
    revisions?: IntFieldUpdateOperationsInput | number
    status?: EnumGigOrderStatusFieldUpdateOperationsInput | $Enums.GigOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FreelancerProfileCountOutputTypeDefaultArgs instead
     */
    export type FreelancerProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FreelancerProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractCountOutputTypeDefaultArgs instead
     */
    export type ContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GigCountOutputTypeDefaultArgs instead
     */
    export type GigCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GigCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FreelancerProfileDefaultArgs instead
     */
    export type FreelancerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FreelancerProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileDefaultArgs instead
     */
    export type ClientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FreelancerSkillDefaultArgs instead
     */
    export type FreelancerSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FreelancerSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectSkillDefaultArgs instead
     */
    export type ProjectSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BidDefaultArgs instead
     */
    export type BidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BidDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminActionDefaultArgs instead
     */
    export type AdminActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GigDefaultArgs instead
     */
    export type GigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GigOrderDefaultArgs instead
     */
    export type GigOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GigOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GigReviewDefaultArgs instead
     */
    export type GigReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GigReviewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}